<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHP II: Βάσεις Δεδομένων & MySQL</title>
    <link rel="stylesheet" href="styles.css">
    <script src="course-interactions.js" defer></script>
    <script>
        window.isIndexPage = false;
    </script>
</head>
<body>
    <script>
        window.isIndexPage = false;
    </script>
    <div class="container">
        <a href="index.html" class="back-to-index">← Επιστροφή στο Ευρετήριο</a>
        <h1>PHP II: Βάσεις Δεδομένων & MySQL</h1>
        
        <section id="database-intro">
            <h2>1. Εισαγωγή στις Βάσεις Δεδομένων</h2>
            
            <p>Οι βάσεις δεδομένων αποτελούν θεμελιώδες στοιχείο των σύγχρονων διαδικτυακών εφαρμογών, επιτρέποντας την αποθήκευση, οργάνωση και ανάκτηση δεδομένων με αποτελεσματικό και ασφαλή τρόπο. Σε συνδυασμό με την PHP, οι βάσεις δεδομένων επιτρέπουν τη δημιουργία δυναμικών εφαρμογών που μπορούν να διαχειριστούν μεγάλο όγκο πληροφοριών.</p>
            
            <h3>Τι είναι μια Βάση Δεδομένων;</h3>
            <p>Μια βάση δεδομένων είναι μια οργανωμένη συλλογή δεδομένων, αποθηκευμένη και προσβάσιμη ηλεκτρονικά. Σε αντίθεση με τα απλά αρχεία, οι βάσεις δεδομένων παρέχουν πολλές επιπλέον δυνατότητες:</p>
            
            <ul>
                <li><strong>Αποτελεσματική αποθήκευση και ανάκτηση:</strong> Βελτιστοποιημένες μέθοδοι για την αποθήκευση και την ανάκτηση μεγάλων ποσοτήτων δεδομένων</li>
                <li><strong>Ταυτόχρονη πρόσβαση:</strong> Πολλοί χρήστες μπορούν να έχουν πρόσβαση στα δεδομένα ταυτόχρονα</li>
                <li><strong>Ασφάλεια:</strong> Έλεγχος πρόσβασης και προστασία των δεδομένων</li>
                <li><strong>Ακεραιότητα δεδομένων:</strong> Εξασφάλιση ότι τα δεδομένα παραμένουν ακριβή και συνεπή</li>
                <li><strong>Σχεσιακές συνδέσεις:</strong> Δυνατότητα συσχέτισης δεδομένων μεταξύ διαφορετικών πινάκων</li>
            </ul>
            
            <h3>Συστήματα Διαχείρισης Βάσεων Δεδομένων (DBMS)</h3>
            <p>Ένα Σύστημα Διαχείρισης Βάσεων Δεδομένων (Database Management System - DBMS) είναι λογισμικό που αλληλεπιδρά με τον χρήστη, άλλες εφαρμογές και την ίδια τη βάση δεδομένων για τη συλλογή και ανάλυση δεδομένων. Διαχειρίζεται τη βάση δεδομένων και παρέχει ένα περιβάλλον όπου οι χρήστες μπορούν να αποθηκεύουν, να οργανώνουν και να ανακτούν δεδομένα.</p>
            
            <p>Μερικά δημοφιλή DBMS είναι:</p>
            <ul>
                <li><strong>MySQL:</strong> Ανοιχτού κώδικα, κατάλληλο για μικρές έως μεσαίες εφαρμογές ιστού</li>
                <li><strong>PostgreSQL:</strong> Ανοιχτού κώδικα, με έμφαση στην επεκτασιμότητα και τη συμμόρφωση με πρότυπα</li>
                <li><strong>Oracle Database:</strong> Εμπορικό DBMS για επιχειρήσεις</li>
                <li><strong>Microsoft SQL Server:</strong> Εμπορικό DBMS από τη Microsoft</li>
                <li><strong>SQLite:</strong> Ελαφρύ DBMS, κατάλληλο για ενσωματωμένες εφαρμογές</li>
                <li><strong>MongoDB:</strong> Μη σχεσιακή (NoSQL) βάση δεδομένων, προσανατολισμένη σε έγγραφα</li>
            </ul>
            
            <div class="callout">
                <p><strong>Σημείωση:</strong> Σε αυτό το μάθημα θα επικεντρωθούμε στη MySQL, καθώς είναι μία από τις πιο δημοφιλείς επιλογές για ανάπτυξη εφαρμογών ιστού με PHP και είναι διαθέσιμη στα περισσότερα περιβάλλοντα φιλοξενίας ιστοσελίδων.</p>
            </div>
            
            <h3>Τύποι Βάσεων Δεδομένων</h3>
            <p>Υπάρχουν διάφοροι τύποι βάσεων δεδομένων, με τις πιο κοινές κατηγορίες να είναι:</p>
            
            <h4>1. Σχεσιακές Βάσεις Δεδομένων</h4>
            <p>Οι σχεσιακές βάσεις δεδομένων οργανώνουν τα δεδομένα σε πίνακες (ή "σχέσεις") με γραμμές και στήλες. Κάθε πίνακας έχει ένα μοναδικό κλειδί που προσδιορίζει κάθε γραμμή, και οι πίνακες μπορούν να συσχετιστούν μεταξύ τους με τη χρήση αυτών των κλειδιών.</p>
            
            <p>Χαρακτηριστικά:</p>
            <ul>
                <li>Χρησιμοποιούν την SQL (Structured Query Language) για τη διαχείριση των δεδομένων</li>
                <li>Εξασφαλίζουν τις αρχές ACID (Atomicity, Consistency, Isolation, Durability)</li>
                <li>Παραδείγματα: MySQL, PostgreSQL, Oracle, SQL Server</li>
            </ul>
            
            <h4>2. Μη Σχεσιακές Βάσεις Δεδομένων (NoSQL)</h4>
            <p>Οι μη σχεσιακές βάσεις δεδομένων παρέχουν έναν μηχανισμό για την αποθήκευση και ανάκτηση δεδομένων που μοντελοποιούνται με τρόπους διαφορετικούς από τον παραδοσιακό πινακοειδή τρόπο των σχεσιακών βάσεων δεδομένων.</p>
            
            <p>Κύριοι τύποι NoSQL βάσεων δεδομένων:</p>
            <ul>
                <li><strong>Document stores:</strong> Αποθηκεύουν δεδομένα σε μορφή εγγράφων (π.χ., JSON, BSON), όπως το MongoDB</li>
                <li><strong>Key-value stores:</strong> Αποθηκεύουν δεδομένα ως ζεύγη κλειδιού-τιμής, όπως το Redis</li>
                <li><strong>Column-family stores:</strong> Αποθηκεύουν δεδομένα σε οικογένειες στηλών, όπως το Cassandra</li>
                <li><strong>Graph databases:</strong> Αποθηκεύουν δεδομένα σε γραφήματα με κόμβους και ακμές, όπως το Neo4j</li>
            </ul>
            
            <h3>Σχεδιασμός Βάσεων Δεδομένων</h3>
            <p>Ο σχεδιασμός βάσεων δεδομένων είναι η διαδικασία παραγωγής ενός λεπτομερούς μοντέλου δεδομένων για μια βάση δεδομένων. Αυτό το μοντέλο περιέχει όλους τους απαραίτητους λογικούς και φυσικούς σχεδιαστικούς περιορισμούς που απαιτούνται για τη δημιουργία της βάσης δεδομένων.</p>
            
            <h4>Βασικές Έννοιες</h4>
            <ul>
                <li><strong>Οντότητες:</strong> Τα βασικά αντικείμενα ή έννοιες που θέλουμε να αποθηκεύσουμε (π.χ., χρήστες, προϊόντα, παραγγελίες)</li>
                <li><strong>Ιδιότητες:</strong> Τα χαρακτηριστικά των οντοτήτων (π.χ., όνομα, τιμή, ημερομηνία)</li>
                <li><strong>Σχέσεις:</strong> Οι συνδέσεις μεταξύ των οντοτήτων (π.χ., ένας χρήστης μπορεί να έχει πολλές παραγγελίες)</li>
                <li><strong>Πρωτεύον κλειδί (Primary Key):</strong> Μια μοναδική ιδιότητα που προσδιορίζει μια συγκεκριμένη εγγραφή</li>
                <li><strong>Ξένο κλειδί (Foreign Key):</strong> Μια ιδιότητα που χρησιμοποιείται για να συνδέσει δύο πίνακες</li>
            </ul>
            
            <h4>Κανονικοποίηση</h4>
            <p>Η κανονικοποίηση είναι η διαδικασία οργάνωσης μιας βάσης δεδομένων για τη μείωση της περιττής εισαγωγής δεδομένων και για την αποφυγή ανωμαλιών κατά την ενημέρωση των δεδομένων. Υπάρχουν διάφορες "κανονικές μορφές" (Normal Forms) που περιγράφουν τα επίπεδα κανονικοποίησης.</p>
            
            <p>Οι τρεις πιο κοινές κανονικές μορφές είναι:</p>
            <ul>
                <li><strong>Πρώτη Κανονική Μορφή (1NF):</strong> 
                    <ul>
                        <li>Κάθε πίνακας έχει ένα πρωτεύον κλειδί</li>
                        <li>Κάθε στήλη περιέχει ατομικές τιμές (όχι λίστες ή πίνακες)</li>
                        <li>Κάθε στήλη περιέχει δεδομένα του ίδιου τύπου</li>
                    </ul>
                </li>
                <li><strong>Δεύτερη Κανονική Μορφή (2NF):</strong> 
                    <ul>
                        <li>Πληροί όλες τις απαιτήσεις της 1NF</li>
                        <li>Όλα τα μη-κλειδιά εξαρτώνται πλήρως από το πρωτεύον κλειδί</li>
                    </ul>
                </li>
                <li><strong>Τρίτη Κανονική Μορφή (3NF):</strong> 
                    <ul>
                        <li>Πληροί όλες τις απαιτήσεις της 2NF</li>
                        <li>Δεν υπάρχουν μεταβατικές εξαρτήσεις (μια μη-κλειδί στήλη δεν πρέπει να εξαρτάται από άλλη μη-κλειδί στήλη)</li>
                    </ul>
                </li>
            </ul>
            
            <h4>Διαγράμματα Οντοτήτων-Συσχετίσεων (ER Diagrams)</h4>
            <p>Τα διαγράμματα Οντοτήτων-Συσχετίσεων (Entity-Relationship Diagrams) είναι ένα εργαλείο για την οπτική αναπαράσταση της δομής μιας βάσης δεδομένων. Αποτελούνται από:</p>
            <ul>
                <li><strong>Οντότητες:</strong> Αναπαριστώνται συνήθως με ορθογώνια</li>
                <li><strong>Ιδιότητες:</strong> Αναπαριστώνται συνήθως με οβάλ και συνδέονται με τις οντότητες</li>
                <li><strong>Σχέσεις:</strong> Αναπαριστώνται συνήθως με ρόμβους και συνδέουν οντότητες</li>
            </ul>
            
            <div class="callout">
                <p><strong>Τύποι Σχέσεων:</strong></p>
                <ul>
                    <li><strong>Ένα-προς-ένα (1:1):</strong> Μία εγγραφή στον πίνακα Α συσχετίζεται με ακριβώς μία εγγραφή στον πίνακα Β, και αντίστροφα.</li>
                    <li><strong>Ένα-προς-πολλά (1:N):</strong> Μία εγγραφή στον πίνακα Α μπορεί να συσχετίζεται με πολλές εγγραφές στον πίνακα Β, αλλά μία εγγραφή στον πίνακα Β συσχετίζεται με ακριβώς μία εγγραφή στον πίνακα Α.</li>
                    <li><strong>Πολλά-προς-πολλά (M:N):</strong> Μία εγγραφή στον πίνακα Α μπορεί να συσχετίζεται με πολλές εγγραφές στον πίνακα Β, και μία εγγραφή στον πίνακα Β μπορεί να συσχετίζεται με πολλές εγγραφές στον πίνακα Α.</li>
                </ul>
            </div>
            
            <h3>Πλεονεκτήματα της Χρήσης Βάσεων Δεδομένων με την PHP</h3>
            <p>Η χρήση βάσεων δεδομένων σε συνδυασμό με την PHP προσφέρει πολλά πλεονεκτήματα για την ανάπτυξη διαδικτυακών εφαρμογών:</p>
            
            <ul>
                <li><strong>Διαχωρισμός παρουσίασης και δεδομένων:</strong> Ο κώδικας PHP μπορεί να επικεντρωθεί στην παρουσίαση, ενώ η βάση δεδομένων διαχειρίζεται την αποθήκευση και ανάκτηση δεδομένων</li>
                <li><strong>Κλιμάκωση:</strong> Οι εφαρμογές μπορούν να χειριστούν περισσότερα δεδομένα και χρήστες καθώς αναπτύσσονται</li>
                <li><strong>Ασφάλεια:</strong> Οι σύγχρονες βάσεις δεδομένων παρέχουν ισχυρούς μηχανισμούς ασφαλείας</li>
                <li><strong>Δομημένη αποθήκευση:</strong> Τα δεδομένα αποθηκεύονται με οργανωμένο τρόπο</li>
                <li><strong>Αποτελεσματική αναζήτηση:</strong> Γρήγορη και αποτελεσματική ανάκτηση δεδομένων</li>
                <li><strong>Συνέπεια δεδομένων:</strong> Διατήρηση της ακεραιότητας των δεδομένων</li>
                <li><strong>Ταυτόχρονη πρόσβαση:</strong> Πολλοί χρήστες μπορούν να έχουν πρόσβαση στα δεδομένα ταυτόχρονα</li>
            </ul>
            
            <h3>Μοντέλο Client-Server</h3>
            <p>Οι περισσότερες βάσεις δεδομένων λειτουργούν σε ένα μοντέλο client-server, όπου:</p>
            <ul>
                <li><strong>Server (Διακομιστής):</strong> Το λογισμικό DBMS που εκτελείται και διαχειρίζεται τη βάση δεδομένων</li>
                <li><strong>Client (Πελάτης):</strong> Η εφαρμογή (στην περίπτωσή μας, ένα PHP script) που συνδέεται στο διακομιστή για να κάνει ερωτήματα και να λάβει αποτελέσματα</li>
            </ul>
            
            <p>Αυτό το μοντέλο επιτρέπει την κεντρική διαχείριση δεδομένων, ενώ πολλαπλοί πελάτες μπορούν να συνδεθούν και να αλληλεπιδράσουν με τη βάση δεδομένων.</p>
            
            <div class="callout">
                <p><strong>Σε μια τυπική εφαρμογή PHP + MySQL:</strong></p>
                <ol>
                    <li>Ο χρήστης αλληλεπιδρά με μια ιστοσελίδα από το πρόγραμμα περιήγησης</li>
                    <li>Η ιστοσελίδα στέλνει ένα αίτημα στον διακομιστή ιστού</li>
                    <li>Ο διακομιστής ιστού εκτελεί ένα script PHP</li>
                    <li>Το script PHP συνδέεται στον διακομιστή MySQL ως πελάτης</li>
                    <li>Το script στέλνει ερωτήματα SQL στη βάση δεδομένων</li>
                    <li>Η βάση δεδομένων επιστρέφει τα αποτελέσματα στο script PHP</li>
                    <li>Το script PHP επεξεργάζεται τα αποτελέσματα και δημιουργεί HTML</li>
                    <li>Ο διακομιστής ιστού στέλνει την HTML πίσω στο πρόγραμμα περιήγησης του χρήστη</li>
                </ol>
            </div>
        </section>
        
        <section id="mysql-basics">
            <h2>2. Βασικά MySQL</h2>
            
            <p>Η MySQL είναι ένα από τα πιο δημοφιλή συστήματα διαχείρισης σχεσιακών βάσεων δεδομένων ανοιχτού κώδικα. Είναι γνωστή για την ταχύτητα, την αξιοπιστία και την ευκολία χρήσης της, και χρησιμοποιείται ευρέως στην ανάπτυξη διαδικτυακών εφαρμογών, ιδιαίτερα σε συνδυασμό με την PHP.</p>
            
            <h3>Χαρακτηριστικά της MySQL</h3>
            <ul>
                <li><strong>Ανοιχτού κώδικα:</strong> Διατίθεται δωρεάν κάτω από άδεια GPL (υπάρχουν επίσης εμπορικές άδειες)</li>
                <li><strong>Διαπλατφορμική:</strong> Λειτουργεί σε διάφορα λειτουργικά συστήματα (Windows, Linux, macOS, κ.λπ.)</li>
                <li><strong>Ισχυρή υποστήριξη SQL:</strong> Υποστηρίζει τις περισσότερες λειτουργίες της SQL (ANSI/ISO)</li>
                <li><strong>Κλιμακωσιμότητα:</strong> Μπορεί να διαχειριστεί βάσεις δεδομένων από μερικά MB έως πολλά TB</li>
                <li><strong>Υψηλή απόδοση:</strong> Βελτιστοποιημένη για ταχύτητα</li>
                <li><strong>Αξιοπιστία:</strong> Έχει αποδείξει την αξιοπιστία της σε πολλές παραγωγικές εφαρμογές</li>
                <li><strong>Υποστήριξη συναλλαγών:</strong> Με τη χρήση μηχανών αποθήκευσης όπως το InnoDB</li>
                <li><strong>Ασφάλεια:</strong> Προσφέρει ισχυρά χαρακτηριστικά ασφαλείας</li>
            </ul>
            
            <h3>Εγκατάσταση και Ρύθμιση της MySQL</h3>
            <p>Η MySQL μπορεί να εγκατασταθεί με διάφορους τρόπους, ανάλογα με το λειτουργικό σας σύστημα και τις προτιμήσεις σας.</p>
            
            <h4>Χρήση πακέτων XAMPP/WAMP/MAMP</h4>
            <p>Τα πακέτα αυτά περιλαμβάνουν ήδη τη MySQL μαζί με τον Apache και την PHP:</p>
            <ul>
                <li><strong>XAMPP:</strong> Διαθέσιμο για Windows, Linux και macOS</li>
                <li><strong>WAMP:</strong> Για Windows</li>
                <li><strong>MAMP:</strong> Για macOS</li>
            </ul>
            
            <div class="callout">
                <p><strong>Σημείωση:</strong> Αν έχετε ήδη εγκαταστήσει κάποιο από αυτά τα πακέτα στο μάθημα PHP I, η MySQL είναι ήδη διαθέσιμη και δεν χρειάζεται επιπλέον εγκατάσταση.</p>
            </div>
            
            <h4>Απευθείας Εγκατάσταση</h4>
            <p>Μπορείτε επίσης να εγκαταστήσετε τη MySQL απευθείας από την επίσημη ιστοσελίδα:</p>
            <ol>
                <li>Επισκεφθείτε το <a href="https://dev.mysql.com/downloads/mysql/" target="_blank">https://dev.mysql.com/downloads/mysql/</a></li>
                <li>Κατεβάστε την έκδοση που ταιριάζει στο λειτουργικό σας σύστημα</li>
                <li>Ακολουθήστε τις οδηγίες εγκατάστασης</li>
                <li>Κατά την εγκατάσταση, θα σας ζητηθεί να ορίσετε ένα κωδικό για τον χρήστη root</li>
            </ol>
            
            <h4>Πρόσβαση στη MySQL</h4>
            <p>Μετά την εγκατάσταση, μπορείτε να αποκτήσετε πρόσβαση στη MySQL με διάφορους τρόπους:</p>
            
            <ul>
                <li><strong>Γραμμή εντολών:</strong> Χρησιμοποιώντας το εργαλείο mysql client</li>
                <li><strong>phpMyAdmin:</strong> Ένα εργαλείο διαχείρισης MySQL μέσω περιηγητή (συμπεριλαμβάνεται στα περισσότερα πακέτα AMP)</li>
                <li><strong>MySQL Workbench:</strong> Ένα οπτικό εργαλείο για σχεδιασμό, ανάπτυξη και διαχείριση βάσεων δεδομένων MySQL</li>
                <li><strong>Άλλα εργαλεία:</strong> Όπως Navicat, HeidiSQL, DBeaver, κ.λπ.</li>
            </ul>
            
            <h4>Χρήση του phpMyAdmin</h4>
            <p>Το phpMyAdmin είναι ένα από τα πιο δημοφιλή εργαλεία για τη διαχείριση βάσεων δεδομένων MySQL μέσω ενός περιηγητή. Αν χρησιμοποιείτε κάποιο πακέτο AMP, είναι συνήθως διαθέσιμο στη διεύθυνση <code>http://localhost/phpmyadmin/</code>.</p>
            
            <p>Με το phpMyAdmin μπορείτε να:</p>
            <ul>
                <li>Δημιουργήσετε, τροποποιήσετε και διαγράψετε βάσεις δεδομένων</li>
                <li>Δημιουργήσετε, επεξεργαστείτε και διαγράψετε πίνακες</li>
                <li>Εκτελέσετε ερωτήματα SQL</li>
                <li>Διαχειριστείτε χρήστες και δικαιώματα</li>
                <li>Εισάγετε και εξάγετε δεδομένα σε διάφορες μορφές</li>
                <li>Δημιουργήσετε αντίγραφα ασφαλείας</li>
            </ul>
            
            <div class="callout">
                <p><strong>Συμβουλή:</strong> Για εκπαιδευτικούς σκοπούς, το phpMyAdmin είναι ιδανικό καθώς παρέχει ένα εύχρηστο γραφικό περιβάλλον για τη διαχείριση βάσεων δεδομένων χωρίς να απαιτείται εις βάθος γνώση της γραμμής εντολών.</p>
            </div>
            
            <h3>Βασικές Έννοιες της MySQL</h3>
            
            <h4>Βάσεις Δεδομένων και Πίνακες</h4>
            <p>Η δομή της MySQL οργανώνεται ιεραρχικά:</p>
            <ul>
                <li><strong>Διακομιστής MySQL:</strong> Στο υψηλότερο επίπεδο, ο διακομιστής μπορεί να φιλοξενεί πολλαπλές βάσεις δεδομένων</li>
                <li><strong>Βάση Δεδομένων:</strong> Ένα σύνολο πινάκων που σχετίζονται με ένα συγκεκριμένο σύστημα ή εφαρμογή</li>
                <li><strong>Πίνακας:</strong> Δομή που οργανώνει τα δεδομένα σε γραμμές και στήλες</li>
                <li><strong>Στήλη:</strong> Καθορίζει τον τύπο δεδομένων που μπορεί να αποθηκευτεί (π.χ., αριθμοί, κείμενο, ημερομηνίες)</li>
                <li><strong>Γραμμή:</strong> Μια συγκεκριμένη εγγραφή δεδομένων στον πίνακα</li>
            </ul>
            
            <h4>Τύποι Δεδομένων</h4>
            <p>Η MySQL υποστηρίζει διάφορους τύπους δεδομένων, οι οποίοι καθορίζουν τι είδους πληροφορίες μπορούν να αποθηκευτούν σε κάθε στήλη. Οι βασικές κατηγορίες είναι:</p>

            <h5>Αριθμητικοί Τύποι</h5>
            <table>
                <tr>
                    <th>Τύπος</th>
                    <th>Περιγραφή</th>
                    <th>Εύρος</th>
                </tr>
                <tr>
                    <td>INT</td>
                    <td>Ακέραιος αριθμός</td>
                    <td>-2^31 έως 2^31-1</td>
                </tr>
                <tr>
                    <td>TINYINT</td>
                    <td>Πολύ μικρός ακέραιος</td>
                    <td>-128 έως 127</td>
                </tr>
                <tr>
                    <td>SMALLINT</td>
                    <td>Μικρός ακέραιος</td>
                    <td>-32,768 έως 32,767</td>
                </tr>
                <tr>
                    <td>MEDIUMINT</td>
                    <td>Μεσαίος ακέραιος</td>
                    <td>-8,388,608 έως 8,388,607</td>
                </tr>
                <tr>
                    <td>BIGINT</td>
                    <td>Μεγάλος ακέραιος</td>
                    <td>-2^63 έως 2^63-1</td>
                </tr>
                <tr>
                    <td>FLOAT</td>
                    <td>Αριθμός κινητής υποδιαστολής απλής ακρίβειας</td>
                    <td>Ποικίλλει</td>
                </tr>
                <tr>
                    <td>DOUBLE</td>
                    <td>Αριθμός κινητής υποδιαστολής διπλής ακρίβειας</td>
                    <td>Ποικίλλει</td>
                </tr>
                <tr>
                    <td>DECIMAL</td>
                    <td>Αριθμός σταθερής υποδιαστολής για ακριβείς υπολογισμούς</td>
                    <td>Εξαρτάται από τις παραμέτρους</td>
                </tr>
            </table>

            <h5>Τύποι Κειμένου</h5>
            <table>
                <tr>
                    <th>Τύπος</th>
                    <th>Περιγραφή</th>
                    <th>Μέγιστο Μέγεθος</th>
                </tr>
                <tr>
                    <td>CHAR</td>
                    <td>Συμβολοσειρά σταθερού μήκους</td>
                    <td>0 έως 255 χαρακτήρες</td>
                </tr>
                <tr>
                    <td>VARCHAR</td>
                    <td>Συμβολοσειρά μεταβλητού μήκους</td>
                    <td>0 έως 65,535 χαρακτήρες</td>
                </tr>
                <tr>
                    <td>TINYTEXT</td>
                    <td>Πολύ μικρό κείμενο</td>
                    <td>Έως 255 χαρακτήρες</td>
                </tr>
                <tr>
                    <td>TEXT</td>
                    <td>Κείμενο μεσαίου μεγέθους</td>
                    <td>Έως 65,535 χαρακτήρες</td>
                </tr>
                <tr>
                    <td>MEDIUMTEXT</td>
                    <td>Κείμενο μεσαίου-μεγάλου μεγέθους</td>
                    <td>Έως 16,777,215 χαρακτήρες</td>
                </tr>
                <tr>
                    <td>LONGTEXT</td>
                    <td>Μεγάλο κείμενο</td>
                    <td>Έως 4,294,967,295 χαρακτήρες</td>
                </tr>
            </table>

            <h5>Τύποι Ημερομηνίας και Ώρας</h5>
            <table>
                <tr>
                    <th>Τύπος</th>
                    <th>Περιγραφή</th>
                    <th>Μορφή</th>
                </tr>
                <tr>
                    <td>DATE</td>
                    <td>Ημερομηνία</td>
                    <td>'YYYY-MM-DD'</td>
                </tr>
                <tr>
                    <td>TIME</td>
                    <td>Ώρα</td>
                    <td>'HH:MM:SS'</td>
                </tr>
                <tr>
                    <td>DATETIME</td>
                    <td>Συνδυασμός ημερομηνίας και ώρας</td>
                    <td>'YYYY-MM-DD HH:MM:SS'</td>
                </tr>
                <tr>
                    <td>TIMESTAMP</td>
                    <td>Χρονική σήμανση, συχνά για την παρακολούθηση αλλαγών</td>
                    <td>'YYYY-MM-DD HH:MM:SS'</td>
                </tr>
                <tr>
                    <td>YEAR</td>
                    <td>Έτος</td>
                    <td>YYYY</td>
                </tr>
            </table>

            <h5>Άλλοι Τύποι</h5>
            <table>
                <tr>
                    <th>Τύπος</th>
                    <th>Περιγραφή</th>
                </tr>
                <tr>
                    <td>ENUM</td>
                    <td>Μια λίστα επιτρεπόμενων τιμών από τις οποίες μπορεί να επιλεγεί μόνο μία</td>
                </tr>
                <tr>
                    <td>SET</td>
                    <td>Μια λίστα επιτρεπόμενων τιμών από τις οποίες μπορούν να επιλεγούν πολλές</td>
                </tr>
                <tr>
                    <td>BLOB</td>
                    <td>Για αποθήκευση δυαδικών δεδομένων (εικόνες, αρχεία, κ.λπ.)</td>
                </tr>
                <tr>
                    <td>JSON (από MySQL 5.7.8)</td>
                    <td>Για αποθήκευση και χειρισμό δεδομένων JSON</td>
                </tr>
            </table>
            
            <div class="callout warning">
                <p><strong>Καλή πρακτική:</strong> Επιλέξτε πάντα τον καταλληλότερο τύπο δεδομένων για κάθε στήλη, λαμβάνοντας υπόψη τόσο τις απαιτήσεις αποθήκευσης όσο και την απόδοση. Για παράδειγμα, χρησιμοποιήστε CHAR για συμβολοσειρές σταθερού μήκους και VARCHAR για συμβολοσειρές μεταβλητού μήκους.</p>
            </div>
            
            <h4>Κλειδιά και Ευρετήρια</h4>
            <p>Τα κλειδιά και τα ευρετήρια είναι ουσιώδη στοιχεία των σχεσιακών βάσεων δεδομένων που βοηθούν στην οργάνωση των δεδομένων και στην επιτάχυνση των αναζητήσεων:</p>
            
            <ul>
                <li><strong>Πρωτεύον Κλειδί (Primary Key):</strong> Μοναδικός αναγνωριστικός αριθμός για κάθε εγγραφή σε έναν πίνακα. Πρέπει να είναι μοναδικό και δεν μπορεί να είναι NULL. Συνήθως χρησιμοποιείται ως η κύρια μέθοδος αναφοράς σε μια συγκεκριμένη εγγραφή.</li>
                <li><strong>Ξένο Κλειδί (Foreign Key):</strong> Μια στήλη ή συνδυασμός στηλών που αναφέρεται στο πρωτεύον κλειδί ενός άλλου πίνακα. Επιτρέπει τη δημιουργία σχέσεων μεταξύ πινάκων.</li>
                <li><strong>Μοναδικό Κλειδί (Unique Key):</strong> Παρόμοιο με το πρωτεύον κλειδί, αλλά μπορεί να επιτρέπει τιμές NULL και μπορούν να υπάρχουν περισσότερα από ένα σε έναν πίνακα.</li>
                <li><strong>Ευρετήριο (Index):</strong> Μια δομή δεδομένων που βελτιώνει την ταχύτητα των λειτουργιών ανάκτησης δεδομένων.</li>
            </ul>
            
            <div class="callout">
                <p><strong>Παράδειγμα Σχέσης με Ξένο Κλειδί:</strong></p>
                <p>Ας υποθέσουμε ότι έχουμε δύο πίνακες: <code>users</code> και <code>orders</code>. Κάθε παραγγελία ανήκει σε έναν χρήστη. Ο πίνακας <code>orders</code> θα έχει μια στήλη <code>user_id</code> που είναι ξένο κλειδί που αναφέρεται στο <code>id</code> του πίνακα <code>users</code>.</p>
            </div>
            
            <h3>Structured Query Language (SQL)</h3>
            <p>Η SQL (Structured Query Language) είναι η τυπική γλώσσα για τη διαχείριση και την αλληλεπίδραση με σχεσιακές βάσεις δεδομένων. Με την SQL, μπορείτε να δημιουργήσετε, να τροποποιήσετε και να διαγράψετε βάσεις δεδομένων και πίνακες, καθώς και να εισάγετε, να ενημερώσετε, να διαγράψετε και να ανακτήσετε δεδομένα.</p>
            
            <h4>Κατηγορίες Εντολών SQL</h4>
            <p>Η SQL περιλαμβάνει διάφορες κατηγορίες εντολών, οι κύριες από τις οποίες είναι:</p>
            
            <h5>1. Γλώσσα Ορισμού Δεδομένων (Data Definition Language - DDL)</h5>
            <p>Χρησιμοποιείται για τη δημιουργία και τροποποίηση της δομής της βάσης δεδομένων.</p>
            <ul>
                <li><code>CREATE</code>: Δημιουργία βάσεων δεδομένων, πινάκων, ευρετηρίων, κ.λπ.</li>
                <li><code>ALTER</code>: Τροποποίηση υπαρχόντων αντικειμένων της βάσης δεδομένων</li>
                <li><code>DROP</code>: Διαγραφή αντικειμένων από τη βάση δεδομένων</li>
                <li><code>TRUNCATE</code>: Αφαίρεση όλων των εγγραφών από έναν πίνακα, αλλά διατήρηση της δομής του</li>
            </ul>
            
            <h5>2. Γλώσσα Χειρισμού Δεδομένων (Data Manipulation Language - DML)</h5>
            <p>Χρησιμοποιείται για την επεξεργασία δεδομένων μέσα στη βάση δεδομένων.</p>
            <ul>
                <li><code>SELECT</code>: Ανάκτηση δεδομένων από τη βάση δεδομένων</li>
                <li><code>INSERT</code>: Εισαγωγή νέων δεδομένων στη βάση δεδομένων</li>
                <li><code>UPDATE</code>: Ενημέρωση υπαρχόντων δεδομένων</li>
                <li><code>DELETE</code>: Διαγραφή δεδομένων από τη βάση δεδομένων</li>
            </ul>
            
            <h5>3. Γλώσσα Ελέγχου Δεδομένων (Data Control Language - DCL)</h5>
            <p>Χρησιμοποιείται για τον έλεγχο πρόσβασης στη βάση δεδομένων.</p>
            <ul>
                <li><code>GRANT</code>: Παροχή δικαιωμάτων πρόσβασης σε χρήστες</li>
                <li><code>REVOKE</code>: Αφαίρεση δικαιωμάτων πρόσβασης από χρήστες</li>
            </ul>
            
            <h5>4. Γλώσσα Ελέγχου Συναλλαγών (Transaction Control Language - TCL)</h5>
            <p>Χρησιμοποιείται για τη διαχείριση συναλλαγών στη βάση δεδομένων.</p>
            <ul>
                <li><code>COMMIT</code>: Οριστικοποίηση μιας συναλλαγής</li>
                <li><code>ROLLBACK</code>: Αναίρεση αλλαγών μιας συναλλαγής που δεν έχει γίνει commit</li>
                <li><code>SAVEPOINT</code>: Ορισμός σημείου αποθήκευσης μέσα σε μια συναλλαγή</li>
            </ul>
            
            <h4>Βασικά Παραδείγματα SQL</h4>
            <p>Ας δούμε μερικά βασικά παραδείγματα SQL εντολών που θα χρησιμοποιήσετε συχνά:</p>
            
            <h5>Δημιουργία Βάσης Δεδομένων</h5>
            <pre><code>CREATE DATABASE onlineshop;
            
-- Επιλογή της βάσης δεδομένων για χρήση
USE onlineshop;</code></pre>
            
            <h5>Δημιουργία Πίνακα</h5>
            <pre><code>CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    full_name VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);</code></pre>
            
            <h5>Εισαγωγή Δεδομένων</h5>
            <pre><code>-- Εισαγωγή μιας εγγραφής
INSERT INTO users (username, password, email, full_name) 
VALUES ('johndoe', 'hashed_password_here', 'john@example.com', 'John Doe');

-- Εισαγωγή πολλαπλών εγγραφών
INSERT INTO users (username, password, email, full_name) 
VALUES 
('janedoe', 'hashed_password_here', 'jane@example.com', 'Jane Doe'),
('bobsmith', 'hashed_password_here', 'bob@example.com', 'Bob Smith');</code></pre>
            
            <h5>Ανάκτηση Δεδομένων</h5>
            <pre><code>-- Ανάκτηση όλων των πεδίων όλων των χρηστών
SELECT * FROM users;

-- Ανάκτηση συγκεκριμένων πεδίων
SELECT username, email, full_name FROM users;

-- Ανάκτηση με συνθήκη
SELECT * FROM users WHERE id = 1;

-- Ανάκτηση με πολλαπλές συνθήκες
SELECT * FROM users WHERE created_at > '2023-01-01' AND username LIKE 'j%';

-- Ταξινόμηση αποτελεσμάτων
SELECT * FROM users ORDER BY created_at DESC;

-- Περιορισμός αριθμού αποτελεσμάτων
SELECT * FROM users LIMIT 10;</code></pre>
            
            <h5>Ενημέρωση Δεδομένων</h5>
            <pre><code>-- Ενημέρωση μιας εγγραφής
UPDATE users SET full_name = 'Jonathan Doe' WHERE id = 1;

-- Ενημέρωση πολλαπλών πεδίων
UPDATE users 
SET email = 'newemail@example.com', full_name = 'New Name' 
WHERE username = 'johndoe';</code></pre>
            
            <h5>Διαγραφή Δεδομένων</h5>
            <pre><code>-- Διαγραφή μιας εγγραφής
DELETE FROM users WHERE id = 3;

-- Διαγραφή πολλαπλών εγγραφών με βάση συνθήκη
DELETE FROM users WHERE created_at < '2022-01-01';</code></pre>
            
            <h5>Τροποποίηση Πίνακα</h5>
            <pre><code>-- Προσθήκη νέας στήλης
ALTER TABLE users ADD COLUMN phone VARCHAR(20);

-- Τροποποίηση υπάρχουσας στήλης
ALTER TABLE users MODIFY COLUMN full_name VARCHAR(150);

-- Διαγραφή στήλης
ALTER TABLE users DROP COLUMN phone;</code></pre>
            
            <h5>Δημιουργία Ξένου Κλειδιού</h5>
            <pre><code>CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);</code></pre>
            
            <div class="callout warning">
                <p><strong>ΠΡΟΣΟΧΗ:</strong> Όταν εκτελείτε εντολές <code>DELETE</code> ή <code>UPDATE</code>, είναι πολύ σημαντικό να συμπεριλαμβάνετε τη συνθήκη <code>WHERE</code>, διαφορετικά η εντολή θα εφαρμοστεί σε ΌΛΕΣ τις εγγραφές του πίνακα!</p>
            </div>
            
            <h3>Σχέσεις μεταξύ Πινάκων</h3>
            <p>Οι σχέσεις μεταξύ πινάκων είναι ένα από τα ισχυρότερα χαρακτηριστικά των σχεσιακών βάσεων δεδομένων. Επιτρέπουν τη σύνδεση δεδομένων από διαφορετικούς πίνακες και τη διατήρηση της ακεραιότητας των δεδομένων.</p>
            
            <h4>Τύποι Σχέσεων</h4>
            
            <h5>1. Σχέση Ένα-προς-Ένα (One-to-One)</h5>
            <p>Στη σχέση ένα-προς-ένα, μια εγγραφή στον πρώτο πίνακα σχετίζεται με ακριβώς μία εγγραφή στον δεύτερο πίνακα και αντίστροφα.</p>
            <p><strong>Παράδειγμα:</strong> Ένας χρήστης έχει ακριβώς ένα προφίλ και ένα προφίλ ανήκει σε ακριβώς έναν χρήστη.</p>
            
            <pre><code>CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE
);

CREATE TABLE profiles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT UNIQUE,
    full_name VARCHAR(100),
    bio TEXT,
    profile_picture VARCHAR(255),
    FOREIGN KEY (user_id) REFERENCES users(id)
);</code></pre>
            
            <h5>2. Σχέση Ένα-προς-Πολλά (One-to-Many)</h5>
            <p>Στη σχέση ένα-προς-πολλά, μια εγγραφή στον πρώτο πίνακα μπορεί να σχετίζεται με πολλές εγγραφές στον δεύτερο πίνακα, αλλά μια εγγραφή στον δεύτερο πίνακα σχετίζεται με ακριβώς μία εγγραφή στον πρώτο πίνακα.</p>
            <p><strong>Παράδειγμα:</strong> Ένας χρήστης μπορεί να έχει πολλές παραγγελίες, αλλά κάθε παραγγελία ανήκει σε έναν μόνο χρήστη.</p>
            
            <pre><code>CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE
);

CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);</code></pre>
            
            <h5>3. Σχέση Πολλά-προς-Πολλά (Many-to-Many)</h5>
            <p>Στη σχέση πολλά-προς-πολλά, πολλές εγγραφές στον πρώτο πίνακα μπορούν να σχετίζονται με πολλές εγγραφές στον δεύτερο πίνακα. Αυτό απαιτεί τη χρήση ενός τρίτου πίνακα, που ονομάζεται πίνακας συσχέτισης (junction table ή pivot table).</p>
            <p><strong>Παράδειγμα:</strong> Ένα προϊόν μπορεί να ανήκει σε πολλές κατηγορίες και μια κατηγορία μπορεί να περιέχει πολλά προϊόντα.</p>
            
            <pre><code>CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2) NOT NULL
);

CREATE TABLE categories (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL
);

-- Πίνακας συσχέτισης
CREATE TABLE product_categories (
    product_id INT NOT NULL,
    category_id INT NOT NULL,
    PRIMARY KEY (product_id, category_id), -- Σύνθετο πρωτεύον κλειδί
    FOREIGN KEY (product_id) REFERENCES products(id),
    FOREIGN KEY (category_id) REFERENCES categories(id)
);</code></pre>
            
            <h4>Ενώσεις (Joins)</h4>
            <p>Οι ενώσεις επιτρέπουν την ανάκτηση δεδομένων από πολλαπλούς πίνακες με βάση τις σχέσεις μεταξύ τους. Υπάρχουν διάφοροι τύποι ενώσεων:</p>
            
            <ul>
                <li><strong>INNER JOIN:</strong> Επιστρέφει εγγραφές όταν υπάρχει τουλάχιστον μια αντιστοιχία μεταξύ των πινάκων</li>
                <li><strong>LEFT JOIN (ή LEFT OUTER JOIN):</strong> Επιστρέφει όλες τις εγγραφές από τον αριστερό πίνακα και τις αντίστοιχες εγγραφές από τον δεξί πίνακα</li>
                <li><strong>RIGHT JOIN (ή RIGHT OUTER JOIN):</strong> Επιστρέφει όλες τις εγγραφές από τον δεξί πίνακα και τις αντίστοιχες εγγραφές από τον αριστερό πίνακα</li>
                <li><strong>FULL JOIN (ή FULL OUTER JOIN):</strong> Επιστρέφει εγγραφές όταν υπάρχει αντιστοιχία σε οποιονδήποτε από τους δύο πίνακες (δεν υποστηρίζεται άμεσα από τη MySQL)</li>
            </ul>
            
            <h5>Παραδείγματα Ενώσεων</h5>
            
            <pre><code>-- INNER JOIN: Ανάκτηση όλων των παραγγελιών με τα στοιχεία των χρηστών
SELECT orders.id, orders.order_date, orders.total_amount, users.username, users.email
FROM orders
INNER JOIN users ON orders.user_id = users.id;

-- LEFT JOIN: Ανάκτηση όλων των χρηστών και των παραγγελιών τους (συμπεριλαμβανομένων των χρηστών χωρίς παραγγελίες)
SELECT users.username, users.email, orders.id, orders.order_date, orders.total_amount
FROM users
LEFT JOIN orders ON users.id = orders.user_id;

-- Ένωση τριών πινάκων: Χρήστες, Παραγγελίες και Λεπτομέρειες παραγγελιών
SELECT users.username, orders.id AS order_id, products.name AS product_name, order_items.quantity
FROM users
INNER JOIN orders ON users.id = orders.user_id
INNER JOIN order_items ON orders.id = order_items.order_id
INNER JOIN products ON order_items.product_id = products.id;</code></pre>
            
            <div class="callout">
                <p><strong>Συμβουλή:</strong> Οι ενώσεις είναι ισχυρές, αλλά μπορούν επίσης να επηρεάσουν την απόδοση σε μεγάλες βάσεις δεδομένων. Είναι καλή πρακτική να χρησιμοποιείτε κατάλληλα ευρετήρια στις στήλες που χρησιμοποιούνται για συνδέσεις και να περιορίζετε το αποτέλεσμα μόνο στις στήλες που χρειάζεστε.</p>
            </div>
            
            <h3>Ασφάλεια της Βάσης Δεδομένων</h3>
            <p>Η ασφάλεια της βάσης δεδομένων είναι κρίσιμης σημασίας, ειδικά για διαδικτυακές εφαρμογές. Ορισμένες βασικές πρακτικές ασφαλείας περιλαμβάνουν:</p>
            
            <h4>Έλεγχος Πρόσβασης</h4>
            <p>Η MySQL επιτρέπει τη δημιουργία χρηστών με συγκεκριμένα δικαιώματα:</p>
            
            <pre><code>-- Δημιουργία νέου χρήστη
CREATE USER 'newuser'@'localhost' IDENTIFIED BY 'password';

-- Παροχή περιορισμένων δικαιωμάτων
GRANT SELECT, INSERT, UPDATE ON onlineshop.* TO 'newuser'@'localhost';

-- Εφαρμογή των αλλαγών
FLUSH PRIVILEGES;</code></pre>
            
            <h4>Προστασία από SQL Injection</h4>
            <p>Η επίθεση SQL Injection είναι μια από τις πιο κοινές και επικίνδυνες απειλές για διαδικτυακές εφαρμογές. Συμβαίνει όταν ο επιτιθέμενος μπορεί να εισάγει κακόβουλο SQL κώδικα μέσω της εισόδου των χρηστών.</p>
            
            <p><strong>Παράδειγμα ευάλωτου κώδικα:</strong></p>
            <pre><code>// ΜΗΝ το κάνετε αυτό!
$username = $_POST['username'];
$query = "SELECT * FROM users WHERE username = '$username'";
$result = mysqli_query($connection, $query);</code></pre>
            
            <p><strong>Ασφαλής προσέγγιση με προετοιμασμένες δηλώσεις:</strong></p>
            <pre><code>// Σωστή προσέγγιση
$username = $_POST['username'];

// Με τη χρήση του mysqli
$stmt = $connection->prepare("SELECT * FROM users WHERE username = ?");
$stmt->bind_param("s", $username);
$stmt->execute();
$result = $stmt->get_result();

// Ή με τη χρήση του PDO
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = ?");
$stmt->execute([$username]);
$result = $stmt->fetchAll();</code></pre>
            
            <div class="callout warning">
                <p><strong>ΣΗΜΑΝΤΙΚΟ:</strong> Ποτέ μην εμπιστεύεστε την είσοδο των χρηστών! Πάντα να χρησιμοποιείτε προετοιμασμένες δηλώσεις (prepared statements) ή παραμετροποιημένα ερωτήματα για να αποφύγετε επιθέσεις SQL injection.</p>
            </div>
            
            <h4>Κρυπτογράφηση Ευαίσθητων Δεδομένων</h4>
            <p>Ευαίσθητα δεδομένα όπως οι κωδικοί πρόσβασης πρέπει πάντα να κρυπτογραφούνται πριν αποθηκευτούν στη βάση δεδομένων:</p>
            
            <pre><code>// Κρυπτογράφηση κωδικού πρόσβασης με το password_hash της PHP
$password = $_POST['password'];
$hashed_password = password_hash($password, PASSWORD_DEFAULT);

// Αποθήκευση του κρυπτογραφημένου κωδικού στη βάση
$stmt = $pdo->prepare("INSERT INTO users (username, password, email) VALUES (?, ?, ?)");
$stmt->execute([$username, $hashed_password, $email]);

// Αργότερα, για επαλήθευση του κωδικού
$stmt = $pdo->prepare("SELECT password FROM users WHERE username = ?");
$stmt->execute([$username]);
$user = $stmt->fetch();

if (password_verify($password, $user['password'])) {
    // Επιτυχής σύνδεση
} else {
    // Αποτυχημένη σύνδεση
}</code></pre>
            
            <h3>Βελτιστοποίηση Απόδοσης</h3>
            <p>Η βελτιστοποίηση της απόδοσης της βάσης δεδομένων είναι σημαντική για τη διατήρηση της ταχύτητας και της αποτελεσματικότητας της εφαρμογής σας, ειδικά καθώς μεγαλώνει.</p>
            
            <h4>Βασικές Τεχνικές Βελτιστοποίησης</h4>
            <ul>
                <li><strong>Χρήση Ευρετηρίων:</strong> Τα ευρετήρια επιταχύνουν τις αναζητήσεις αλλά επιβραδύνουν τις εισαγωγές και ενημερώσεις.
                    <pre><code>-- Δημιουργία ευρετηρίου σε μια στήλη
CREATE INDEX idx_username ON users(username);

-- Δημιουργία ευρετηρίου σε πολλαπλές στήλες
CREATE INDEX idx_name_email ON users(username, email);</code></pre>
                </li>
                <li><strong>Βελτιστοποίηση Ερωτημάτων:</strong> Αποφύγετε τη χρήση <code>SELECT *</code> και ανακτήστε μόνο τις στήλες που χρειάζεστε.</li>
                <li><strong>Χρήση του EXPLAIN:</strong> Το <code>EXPLAIN</code> παρέχει πληροφορίες για το πώς η MySQL εκτελεί ένα ερώτημα.
                    <pre><code>EXPLAIN SELECT * FROM users WHERE username = 'johndoe';</code></pre>
                </li>
                <li><strong>Περιορισμός των Αποτελεσμάτων:</strong> Χρησιμοποιήστε το <code>LIMIT</code> για να περιορίσετε τον αριθμό των επιστρεφόμενων εγγραφών.</li>
                <li><strong>Χρήση Κατάλληλων Τύπων Δεδομένων:</strong> Επιλέξτε τον πιο κατάλληλο και αποδοτικό τύπο δεδομένων για κάθε στήλη.</li>
            </ul>
            
            <div class="callout">
                <p><strong>Συμβουλή:</strong> Η βελτιστοποίηση βάσεων δεδομένων είναι ένα ευρύ θέμα. Ξεκινήστε με τις βασικές τεχνικές όπως η χρήση ευρετηρίων και η βελτιστοποίηση ερωτημάτων, και στη συνέχεια εμβαθύνετε καθώς αποκτάτε περισσότερη εμπειρία.</p>
            </div>
            
            <h3>Σύστημα Διαχείρισης Περιεχομένου MySQL με phpMyAdmin</h3>
            <p>Το phpMyAdmin παρέχει ένα γραφικό περιβάλλον για τη διαχείριση των βάσεων δεδομένων MySQL. Ας δούμε μερικές βασικές λειτουργίες:</p>
            
            <h4>Δημιουργία Βάσης Δεδομένων</h4>
            <ol>
                <li>Συνδεθείτε στο phpMyAdmin μέσω του περιηγητή σας (συνήθως στη διεύθυνση <code>http://localhost/phpmyadmin/</code>)</li>
                <li>Κάντε κλικ στην καρτέλα "Βάσεις δεδομένων"</li>
                <li>Εισαγάγετε το όνομα της νέας βάσης δεδομένων στο πεδίο "Δημιουργία βάσης δεδομένων"</li>
                <li>Επιλέξτε την κωδικοποίηση χαρακτήρων (προτείνεται η <code>utf8mb4_unicode_ci</code> για υποστήριξη ελληνικών)</li>
                <li>Κάντε κλικ στο "Δημιουργία"</li>
            </ol>
            
            <h4>Δημιουργία Πίνακα</h4>
            <ol>
                <li>Επιλέξτε τη βάση δεδομένων από την αριστερή πλευρική στήλη</li>
                <li>Κάντε κλικ στην καρτέλα "Δομή"</li>
                <li>Εισαγάγετε το όνομα του πίνακα και τον αριθμό των στηλών</li>
                <li>Κάντε κλικ στο "Εκτέλεση"</li>
                <li>Ορίστε τις ιδιότητες κάθε στήλης (όνομα, τύπος, μήκος, κλπ.)</li>
                <li>Ορίστε το πρωτεύον κλειδί επιλέγοντας το πλαίσιο ελέγχου "PRIMARY" δίπλα στην κατάλληλη στήλη</li>
                <li>Κάντε κλικ στο "Αποθήκευση"</li>
            </ol>
            
            <h4>Εισαγωγή Δεδομένων</h4>
            <ol>
                <li>Επιλέξτε τον πίνακα από την αριστερή πλευρική στήλη</li>
                <li>Κάντε κλικ στην καρτέλα "Εισαγωγή"</li>
                <li>Συμπληρώστε τα πεδία για τη νέα εγγραφή</li>
                <li>Κάντε κλικ στο "Εκτέλεση"</li>
            </ol>
            
            <h4>Εκτέλεση SQL Ερωτημάτων</h4>
            <ol>
                <li>Επιλέξτε τη βάση δεδομένων από την αριστερή πλευρική στήλη</li>
                <li>Κάντε κλικ στην καρτέλα "SQL"</li>
                <li>Πληκτρολογήστε το ερώτημα SQL στο πεδίο κειμένου</li>
                <li>Κάντε κλικ στο "Εκτέλεση"</li>
            </ol>
            
            <h4>Εξαγωγή και Εισαγωγή Βάσεων Δεδομένων</h4>
            <p>Το phpMyAdmin επιτρέπει επίσης την εύκολη δημιουργία αντιγράφων ασφαλείας (backup) και την επαναφορά βάσεων δεδομένων:</p>
            <ul>
                <li><strong>Εξαγωγή:</strong> Επιλέξτε τη βάση δεδομένων ή τον πίνακα και κάντε κλικ στην καρτέλα "Εξαγωγή"</li>
                <li><strong>Εισαγωγή:</strong> Κάντε κλικ στην καρτέλα "Εισαγωγή" και επιλέξτε το αρχείο SQL προς εισαγωγή</li>
            </ul>
            
            <div class="callout">
                <p><strong>Συμβουλή:</strong> Το phpMyAdmin είναι ένα ισχυρό εργαλείο για τη διαχείριση βάσεων δεδομένων MySQL, αλλά πρέπει να το χρησιμοποιείτε με προσοχή, ειδικά σε περιβάλλοντα παραγωγής. Πάντα να δημιουργείτε αντίγραφα ασφαλείας πριν κάνετε σημαντικές αλλαγές.</p>
            </div>
            
            <h3>Συμπέρασμα</h3>
            <p>Η MySQL είναι ένα ισχυρό σύστημα διαχείρισης βάσεων δεδομένων που σε συνδυασμό με την PHP, παρέχει μια στιβαρή βάση για την ανάπτυξη διαδικτυακών εφαρμογών. Σε αυτή την ενότητα, καλύψαμε τις βασικές έννοιες των βάσεων δεδομένων και της MySQL, συμπεριλαμβανομένης της δημιουργίας βάσεων δεδομένων και πινάκων, της εκτέλεσης βασικών λειτουργιών SQL και της διαχείρισης σχέσεων μεταξύ πινάκων.</p>
            
            <p>Καθώς συνεχίζετε να μαθαίνετε και να εξασκείστε, θα αποκτήσετε περισσότερη εξοικείωση με αυτές τις έννοιες και θα είστε σε θέση να σχεδιάσετε και να υλοποιήσετε αποτελεσματικές και ασφαλείς βάσεις δεδομένων για τις εφαρμογές σας.</p>
            
            <p>Στις επόμενες ενότητες, θα εξερευνήσουμε πώς να συνδέσουμε την PHP με τη MySQL για τη δημιουργία δυναμικών εφαρμογών ιστού, καθώς και προηγμένες τεχνικές και βέλτιστες πρακτικές.</p>
        </section>
    </div>
    
    <button id="back-to-top" title="Back to top">↑</button>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-jsx.min.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const backToTopButton = document.getElementById('back-to-top');
            if (backToTopButton) {
                window.addEventListener('scroll', function() {
                    if (window.pageYOffset > 300) {
                        backToTopButton.style.display = 'block';
                    } else {
                        backToTopButton.style.display = 'none';
                    }
                });
                
                backToTopButton.addEventListener('click', function() {
                    window.scrollTo({top: 0, behavior: 'smooth'});
                });
            }
            
            // Store section info in localStorage for progress tracking
            function updateSectionInfo() {
                const sections = document.querySelectorAll('section');
                let sectionIds = [];
                
                sections.forEach(section => {
                    sectionIds.push(section.id);
                });
                
                localStorage.setItem('currentPageSections', JSON.stringify(sectionIds));
            }
            
            updateSectionInfo();
        });
    </script>

<section id="connect-database">
    <h2>3. Σύνδεση PHP και MySQL</h2>
    
    <p>Η PHP παρέχει διάφορους τρόπους για να συνδεθείτε και να αλληλεπιδράσετε με βάσεις δεδομένων MySQL. Στις σύγχρονες εφαρμογές PHP, χρησιμοποιούμε κυρίως τις επεκτάσεις MySQLi (MySQL Improved) ή PDO (PHP Data Objects).</p>
    
    <h3>Επισκόπηση των Διαθέσιμων Επεκτάσεων</h3>
    <ul>
        <li><strong>MySQLi:</strong> Μια βελτιωμένη έκδοση της αρχικής επέκτασης MySQL, που προσφέρει καλύτερη ασφάλεια και περισσότερα χαρακτηριστικά</li>
        <li><strong>PDO:</strong> Ένα αφαιρετικό επίπεδο πρόσβασης σε βάσεις δεδομένων που υποστηρίζει πολλά διαφορετικά συστήματα βάσεων δεδομένων</li>
    </ul>
    
    <div class="callout">
        <p><strong>Σημείωση:</strong> Η παλιά επέκταση MySQL (έχει καταργηθεί από την PHP 7.0) δεν πρέπει να χρησιμοποιείται πλέον σε νέα έργα καθώς είναι απαρχαιωμένη και λιγότερο ασφαλής.</p>
    </div>
    
    <h3>Σύγκριση MySQLi και PDO</h3>
    <table>
        <tr>
            <th>Χαρακτηριστικό</th>
            <th>MySQLi</th>
            <th>PDO</th>
        </tr>
        <tr>
            <td>Υποστηριζόμενες βάσεις δεδομένων</td>
            <td>Μόνο MySQL</td>
            <td>12+ διαφορετικά συστήματα</td>
        </tr>
        <tr>
            <td>Διεπαφή</td>
            <td>Διαδικαστική και Αντικειμενοστρεφής</td>
            <td>Μόνο Αντικειμενοστρεφής</td>
        </tr>
        <tr>
            <td>Προετοιμασμένες δηλώσεις</td>
            <td>✓</td>
            <td>✓</td>
        </tr>
        <tr>
            <td>Παραμετροποίηση ερωτημάτων</td>
            <td>✓</td>
            <td>✓</td>
        </tr>
        <tr>
            <td>Φορητότητα κώδικα</td>
            <td>Περιορισμένη</td>
            <td>Υψηλή</td>
        </tr>
    </table>
    
    <div class="callout">
        <p><strong>Ποια να επιλέξω;</strong> Και οι δύο επεκτάσεις είναι καλές επιλογές. Η PDO προσφέρει μεγαλύτερη ευελιξία αν χρειαστεί να αλλάξετε σύστημα βάσης δεδομένων στο μέλλον. Η MySQLi μπορεί να είναι πιο οικεία αν έχετε εμπειρία με την αρχική επέκταση MySQL.</p>
    </div>
    
    <h3>Σύνδεση με MySQLi</h3>
    <p>Η MySQLi προσφέρει δύο στυλ προγραμματισμού: διαδικαστικό και αντικειμενοστρεφές.</p>
    
    <h4>Αντικειμενοστρεφές Στυλ</h4>
    <pre><code>// Σύνδεση στη βάση δεδομένων με το αντικειμενοστρεφές στυλ
$servername = "localhost";
$username = "username";
$password = "password";
$dbname = "database_name";

// Δημιουργία σύνδεσης
$conn = new mysqli($servername, $username, $password, $dbname);

// Έλεγχος σύνδεσης
if ($conn->connect_error) {
    die("Η σύνδεση απέτυχε: " . $conn->connect_error);
}

echo "Επιτυχής σύνδεση";

// Εκτέλεση ερωτήματος
$sql = "SELECT id, username, email FROM users";
$result = $conn->query($sql);

if ($result->num_rows > 0) {
    // Εμφάνιση δεδομένων
    while($row = $result->fetch_assoc()) {
        echo "ID: " . $row["id"] . " - Όνομα: " . $row["username"] . " - Email: " . $row["email"] . "<br>";
    }
} else {
    echo "Δεν βρέθηκαν αποτελέσματα";
}

// Κλείσιμο σύνδεσης
$conn->close();</code></pre>
    
    <h4>Διαδικαστικό Στυλ</h4>
    <pre><code>// Σύνδεση στη βάση δεδομένων με το διαδικαστικό στυλ
$servername = "localhost";
$username = "username";
$password = "password";
$dbname = "database_name";

// Δημιουργία σύνδεσης
$conn = mysqli_connect($servername, $username, $password, $dbname);

// Έλεγχος σύνδεσης
if (!$conn) {
    die("Η σύνδεση απέτυχε: " . mysqli_connect_error());
}

echo "Επιτυχής σύνδεση";

// Εκτέλεση ερωτήματος
$sql = "SELECT id, username, email FROM users";
$result = mysqli_query($conn, $sql);

if (mysqli_num_rows($result) > 0) {
    // Εμφάνιση δεδομένων
    while($row = mysqli_fetch_assoc($result)) {
        echo "ID: " . $row["id"] . " - Όνομα: " . $row["username"] . " - Email: " . $row["email"] . "<br>";
    }
} else {
    echo "Δεν βρέθηκαν αποτελέσματα";
}

// Κλείσιμο σύνδεσης
mysqli_close($conn);</code></pre>
    
    <h3>Σύνδεση με PDO</h3>
    <p>Η PDO χρησιμοποιεί μόνο αντικειμενοστρεφές στυλ και προσφέρει περισσότερη ευελιξία.</p>
    
    <pre><code>// Σύνδεση στη βάση δεδομένων με PDO
$servername = "localhost";
$username = "username";
$password = "password";
$dbname = "database_name";

try {
    // Δημιουργία σύνδεσης
    $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password);
    
    // Ρύθμιση της PDO για να πετάει εξαιρέσεις σε περίπτωση σφαλμάτων
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    echo "Επιτυχής σύνδεση";
    
    // Εκτέλεση ερωτήματος
    $stmt = $conn->prepare("SELECT id, username, email FROM users");
    $stmt->execute();
    
    // Λήψη όλων των αποτελεσμάτων ως πίνακα
    $results = $stmt->fetchAll(PDO::FETCH_ASSOC);
    
    if (count($results) > 0) {
        // Εμφάνιση δεδομένων
        foreach($results as $row) {
            echo "ID: " . $row["id"] . " - Όνομα: " . $row["username"] . " - Email: " . $row["email"] . "<br>";
        }
    } else {
        echo "Δεν βρέθηκαν αποτελέσματα";
    }
} catch(PDOException $e) {
    echo "Η σύνδεση απέτυχε: " . $e->getMessage();
}

// Η σύνδεση PDO κλείνει αυτόματα όταν το script τερματίζεται
// Αλλά μπορείτε να την κλείσετε και χειροκίνητα
$conn = null;</code></pre>
    
    <h3>Καλές Πρακτικές</h3>
    <ul>
        <li><strong>Διαχείριση Σφαλμάτων:</strong> Πάντα να ελέγχετε για σφάλματα κατά τη σύνδεση και την εκτέλεση ερωτημάτων</li>
        <li><strong>Προετοιμασμένες Δηλώσεις:</strong> Χρησιμοποιείτε προετοιμασμένες δηλώσεις για να αποφύγετε επιθέσεις SQL injection</li>
        <li><strong>Κλείσιμο Συνδέσεων:</strong> Κλείνετε τις συνδέσεις μετά τη χρήση τους για την απελευθέρωση πόρων</li>
        <li><strong>Διαπιστευτήρια:</strong> Μην αποθηκεύετε τα διαπιστευτήρια της βάσης δεδομένων στον κώδικα. Χρησιμοποιήστε αρχεία διαμόρφωσης ή μεταβλητές περιβάλλοντος</li>
    </ul>
    
    <div class="callout warning">
        <p><strong>Ασφάλεια!</strong> Ποτέ μην εμπιστεύεστε την είσοδο των χρηστών όταν τη χρησιμοποιείτε σε ερωτήματα SQL. Πάντα να χρησιμοποιείτε προετοιμασμένες δηλώσεις ή παραμετροποιημένα ερωτήματα για την προστασία από επιθέσεις SQL injection.</p>
    </div>
    
    <h3>Δημιουργία Βοηθητικών Συναρτήσεων</h3>
    <p>Συχνά, είναι χρήσιμο να δημιουργείτε βοηθητικές συναρτήσεις για την απλοποίηση της σύνδεσης στη βάση δεδομένων και τη διαχείριση των ερωτημάτων.</p>
    
    <pre><code>// Αρχείο db_connect.php - Συνάρτηση σύνδεσης στη βάση δεδομένων
function connectDB() {
    $servername = "localhost";
    $username = "username";
    $password = "password";
    $dbname = "database_name";
    
    try {
        $conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password);
        $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        return $conn;
    } catch(PDOException $e) {
        die("Η σύνδεση απέτυχε: " . $e->getMessage());
    }
}

// Παράδειγμα χρήσης
function getAllUsers() {
    $conn = connectDB();
    $stmt = $conn->prepare("SELECT * FROM users");
    $stmt->execute();
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
}

// Σε άλλο αρχείο PHP
require_once 'db_connect.php';

$users = getAllUsers();

foreach($users as $user) {
    echo $user['username'] . "<br>";
}</code></pre>
    
    <h3>Χρήση Κλάσεων για τη Διαχείριση των Συνδέσεων</h3>
    <p>Για πιο προηγμένες εφαρμογές, μπορείτε να χρησιμοποιήσετε κλάσεις για την ενθυλάκωση της λογικής σύνδεσης με τη βάση δεδομένων.</p>
    
    <pre><code>// Αρχείο Database.php
class Database {
    private $host = "localhost";
    private $username = "username";
    private $password = "password";
    private $dbname = "database_name";
    private $conn;
    
    // Σύνδεση στη βάση δεδομένων
    public function connect() {
        $this->conn = null;
        
        try {
            $this->conn = new PDO("mysql:host=" . $this->host . ";dbname=" . $this->dbname, $this->username, $this->password);
            $this->conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        } catch(PDOException $e) {
            echo "Σφάλμα σύνδεσης: " . $e->getMessage();
        }
        
        return $this->conn;
    }
}

// Παράδειγμα χρήσης της κλάσης
require_once 'Database.php';

$database = new Database();
$db = $database->connect();

// Τώρα μπορείτε να χρησιμοποιήσετε το $db για ερωτήματα
$stmt = $db->prepare("SELECT * FROM users");
$stmt->execute();
$users = $stmt->fetchAll(PDO::FETCH_ASSOC);</code></pre>
    
    <h3>Διαχείριση Συνδέσεων σε Περιβάλλον Παραγωγής</h3>
    <p>Σε ένα περιβάλλον παραγωγής, είναι σημαντικό να διαχειρίζεστε αποτελεσματικά τις συνδέσεις στη βάση δεδομένων για καλύτερη απόδοση και ασφάλεια.</p>
    
    <ul>
        <li><strong>Persistent Connections:</strong> Μπορείτε να χρησιμοποιήσετε μόνιμες συνδέσεις για την επαναχρησιμοποίηση υφιστάμενων συνδέσεων</li>
        <li><strong>Connection Pools:</strong> Σε εφαρμογές με μεγάλο φόρτο, η χρήση δεξαμενών συνδέσεων μπορεί να βελτιώσει την απόδοση</li>
        <li><strong>Αποθήκευση Διαπιστευτηρίων:</strong> Αποθηκεύστε τα διαπιστευτήρια σε ασφαλείς θέσεις, όπως αρχεία διαμόρφωσης που βρίσκονται εκτός του δημόσιου καταλόγου του διακομιστή</li>
    </ul>
    
    <pre><code>// Παράδειγμα χρήσης μόνιμης σύνδεσης με PDO
$conn = new PDO("mysql:host=$servername;dbname=$dbname", $username, $password, array(
    PDO::ATTR_PERSISTENT => true
));</code></pre>
    
    <div class="callout">
        <p><strong>Συμβουλή:</strong> Δημιουργήστε ένα αρχείο διαμόρφωσης για τα διαπιστευτήρια της βάσης δεδομένων, το οποίο να μην είναι προσβάσιμο από το διαδίκτυο.</p>
        <pre><code>// config.php (αποθηκευμένο εκτός του δημόσιου καταλόγου)
return [
    'database' => [
        'host' => 'localhost',
        'name' => 'database_name',
        'user' => 'username',
        'pass' => 'password'
    ]
];

// Στο αρχείο PHP
$config = require_once '../config.php';
$dbConfig = $config['database'];

$conn = new PDO("mysql:host={$dbConfig['host']};dbname={$dbConfig['name']}", 
                $dbConfig['user'], 
                $dbConfig['pass']);</code></pre>
    </div>
    
    <h3>Συμπέρασμα</h3>
    <p>Η σύνδεση της PHP με τη MySQL είναι ένα θεμελιώδες μέρος της ανάπτυξης διαδικτυακών εφαρμογών. Με τις σύγχρονες επεκτάσεις MySQLi και PDO, έχετε ισχυρά εργαλεία για να αλληλεπιδράσετε με τις βάσεις δεδομένων σας με ασφαλή και αποτελεσματικό τρόπο.</p>
    
    <p>Σε αυτήν την ενότητα, μάθαμε πώς να συνδεόμαστε στη MySQL χρησιμοποιώντας τόσο τη MySQLi όσο και την PDO, πώς να εκτελούμε βασικά ερωτήματα, και κάποιες καλές πρακτικές για τη διαχείριση των συνδέσεων. Στην επόμενη ενότητα, θα εξερευνήσουμε πιο προηγμένες τεχνικές για την εκτέλεση λειτουργιών CRUD (Create, Read, Update, Delete) με τη MySQL.</p>
</section>

<section id="crud-operations">
    <h2>4. Λειτουργίες CRUD</h2>
    
    <p>Οι λειτουργίες CRUD (Create, Read, Update, Delete) αποτελούν τις βασικές λειτουργίες διαχείρισης δεδομένων σε μια εφαρμογή που χρησιμοποιεί βάση δεδομένων. Αυτές οι λειτουργίες επιτρέπουν στις εφαρμογές να δημιουργούν, να διαβάζουν, να ενημερώνουν και να διαγράφουν δεδομένα στη βάση.</p>
    
    <h3>Επισκόπηση των Λειτουργιών CRUD</h3>
    <ul>
        <li><strong>Create (Δημιουργία):</strong> Εισαγωγή νέων δεδομένων στη βάση δεδομένων</li>
        <li><strong>Read (Ανάγνωση):</strong> Ανάκτηση δεδομένων από τη βάση δεδομένων</li>
        <li><strong>Update (Ενημέρωση):</strong> Τροποποίηση υπαρχόντων δεδομένων στη βάση δεδομένων</li>
        <li><strong>Delete (Διαγραφή):</strong> Αφαίρεση δεδομένων από τη βάση δεδομένων</li>
    </ul>
    
    <p>Στις περισσότερες εφαρμογές ιστού, οι λειτουργίες CRUD αντιστοιχούν στις HTTP μεθόδους:</p>
    <ul>
        <li><strong>Create</strong> - HTTP POST</li>
        <li><strong>Read</strong> - HTTP GET</li>
        <li><strong>Update</strong> - HTTP PUT/PATCH</li>
        <li><strong>Delete</strong> - HTTP DELETE</li>
    </ul>
    
    <h3>Υλοποίηση των Λειτουργιών CRUD με PHP και MySQL</h3>
    <p>Ας εξετάσουμε πώς μπορούμε να υλοποιήσουμε κάθε μία από αυτές τις λειτουργίες χρησιμοποιώντας PHP και MySQL.</p>
    
    <h4>1. Create (Δημιουργία) - Εισαγωγή Δεδομένων</h4>
    <p>Η λειτουργία Create χρησιμοποιείται για την εισαγωγή νέων εγγραφών στη βάση δεδομένων. Συνήθως υλοποιείται μέσω μιας φόρμας HTML που στέλνει τα δεδομένα σε ένα script PHP.</p>
    
    <h5>Παράδειγμα με MySQLi (Αντικειμενοστρεφές)</h5>
    <pre><code>// create.php - Εισαγωγή νέου χρήστη στη βάση

// Σύνδεση με τη βάση δεδομένων
$conn = new mysqli("localhost", "username", "password", "database_name");

// Έλεγχος σύνδεσης
if ($conn->connect_error) {
    die("Η σύνδεση απέτυχε: " . $conn->connect_error);
}

// Λήψη δεδομένων από τη φόρμα
$username = $_POST['username'];
$email = $_POST['email'];
$full_name = $_POST['full_name'];

// Δημιουργία προετοιμασμένης δήλωσης
$stmt = $conn->prepare("INSERT INTO users (username, email, full_name) VALUES (?, ?, ?)");
$stmt->bind_param("sss", $username, $email, $full_name);

// Εκτέλεση του ερωτήματος
if ($stmt->execute()) {
    echo "Ο νέος χρήστης δημιουργήθηκε επιτυχώς";
} else {
    echo "Σφάλμα: " . $stmt->error;
}

// Κλείσιμο σύνδεσης
$stmt->close();
$conn->close();</code></pre>
    
    <h5>Παράδειγμα με PDO</h5>
    <pre><code>// create.php - Εισαγωγή νέου χρήστη με PDO

try {
    // Σύνδεση με τη βάση δεδομένων
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Λήψη δεδομένων από τη φόρμα
    $username = $_POST['username'];
    $email = $_POST['email'];
    $full_name = $_POST['full_name'];
    
    // Δημιουργία προετοιμασμένης δήλωσης
    $stmt = $conn->prepare("INSERT INTO users (username, email, full_name) VALUES (:username, :email, :full_name)");
    
    // Εκτέλεση του ερωτήματος με παραμέτρους
    $stmt->execute([
        ':username' => $username,
        ':email' => $email,
        ':full_name' => $full_name
    ]);
    
    echo "Ο νέος χρήστης δημιουργήθηκε επιτυχώς";
} catch(PDOException $e) {
    echo "Σφάλμα: " . $e->getMessage();
}

// Η σύνδεση κλείνει αυτόματα όταν η μεταβλητή βγει εκτός εμβέλειας</code></pre>
    
    <h5>Η HTML Φόρμα</h5>
    <pre><code>&lt;!-- create_form.html - Φόρμα για την εισαγωγή νέου χρήστη --&gt;
&lt;form action="create.php" method="POST"&gt;
    &lt;div&gt;
        &lt;label for="username"&gt;Όνομα Χρήστη:&lt;/label&gt;
        &lt;input type="text" id="username" name="username" required&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        &lt;label for="email"&gt;Email:&lt;/label&gt;
        &lt;input type="email" id="email" name="email" required&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        &lt;label for="full_name"&gt;Πλήρες Όνομα:&lt;/label&gt;
        &lt;input type="text" id="full_name" name="full_name"&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Δημιουργία Χρήστη&lt;/button&gt;
&lt;/form&gt;</code></pre>
    
    <h4>2. Read (Ανάγνωση) - Ανάκτηση Δεδομένων</h4>
    <p>Η λειτουργία Read χρησιμοποιείται για την ανάκτηση δεδομένων από τη βάση δεδομένων. Μπορεί να είναι είτε η ανάκτηση όλων των εγγραφών από έναν πίνακα είτε η ανάκτηση συγκεκριμένων εγγραφών με βάση κάποια κριτήρια.</p>
    
    <h5>Παράδειγμα Ανάκτησης Όλων των Χρηστών (MySQLi)</h5>
    <pre><code>// read_all.php - Ανάκτηση όλων των χρηστών

// Σύνδεση με τη βάση δεδομένων
$conn = new mysqli("localhost", "username", "password", "database_name");

// Έλεγχος σύνδεσης
if ($conn->connect_error) {
    die("Η σύνδεση απέτυχε: " . $conn->connect_error);
}

// Εκτέλεση ερωτήματος
$sql = "SELECT id, username, email, full_name FROM users";
$result = $conn->query($sql);

// Έλεγχος αποτελεσμάτων
if ($result->num_rows > 0) {
    // Εμφάνιση δεδομένων
    echo "&lt;table border='1'&gt;";
    echo "&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Όνομα Χρήστη&lt;/th&gt;&lt;th&gt;Email&lt;/th&gt;&lt;th&gt;Πλήρες Όνομα&lt;/th&gt;&lt;/tr&gt;";
    
    while($row = $result->fetch_assoc()) {
        echo "&lt;tr&gt;";
        echo "&lt;td&gt;" . $row["id"] . "&lt;/td&gt;";
        echo "&lt;td&gt;" . $row["username"] . "&lt;/td&gt;";
        echo "&lt;td&gt;" . $row["email"] . "&lt;/td&gt;";
        echo "&lt;td&gt;" . $row["full_name"] . "&lt;/td&gt;";
        echo "&lt;/tr&gt;";
    }
    
    echo "&lt;/table&gt;";
} else {
    echo "Δεν βρέθηκαν αποτελέσματα";
}

// Κλείσιμο σύνδεσης
$conn->close();</code></pre>
    
    <h5>Παράδειγμα Ανάκτησης Συγκεκριμένου Χρήστη (PDO)</h5>
    <pre><code>// read_single.php - Ανάκτηση συγκεκριμένου χρήστη

// Λήψη του ID του χρήστη από το URL
$user_id = $_GET['id'];

try {
    // Σύνδεση με τη βάση δεδομένων
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Προετοιμασία ερωτήματος
    $stmt = $conn->prepare("SELECT id, username, email, full_name FROM users WHERE id = :id");
    $stmt->execute([':id' => $user_id]);
    
    // Λήψη αποτελέσματος
    $user = $stmt->fetch(PDO::FETCH_ASSOC);
    
    if ($user) {
        // Εμφάνιση δεδομένων χρήστη
        echo "&lt;h2&gt;Στοιχεία Χρήστη&lt;/h2&gt;";
        echo "&lt;p&gt;&lt;strong&gt;ID:&lt;/strong&gt; " . $user["id"] . "&lt;/p&gt;";
        echo "&lt;p&gt;&lt;strong&gt;Όνομα Χρήστη:&lt;/strong&gt; " . $user["username"] . "&lt;/p&gt;";
        echo "&lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt; " . $user["email"] . "&lt;/p&gt;";
        echo "&lt;p&gt;&lt;strong&gt;Πλήρες Όνομα:&lt;/strong&gt; " . $user["full_name"] . "&lt;/p&gt;";
    } else {
        echo "Ο χρήστης δεν βρέθηκε";
    }
} catch(PDOException $e) {
    echo "Σφάλμα: " . $e->getMessage();
}</code></pre>
    
    <h4>3. Update (Ενημέρωση) - Τροποποίηση Δεδομένων</h4>
    <p>Η λειτουργία Update χρησιμοποιείται για την ενημέρωση υπαρχόντων εγγραφών στη βάση δεδομένων. Συνήθως περιλαμβάνει μια φόρμα προσυμπληρωμένη με τα τρέχοντα δεδομένα και ένα script επεξεργασίας για την αποθήκευση των αλλαγών.</p>
    
    <h5>Παράδειγμα με MySQLi</h5>
    <pre><code>// update.php - Ενημέρωση στοιχείων χρήστη

// Σύνδεση με τη βάση δεδομένων
$conn = new mysqli("localhost", "username", "password", "database_name");

// Έλεγχος σύνδεσης
if ($conn->connect_error) {
    die("Η σύνδεση απέτυχε: " . $conn->connect_error);
}

// Λήψη δεδομένων από τη φόρμα
$user_id = $_POST['id'];
$email = $_POST['email'];
$full_name = $_POST['full_name'];

// Δημιουργία προετοιμασμένης δήλωσης
$stmt = $conn->prepare("UPDATE users SET email = ?, full_name = ? WHERE id = ?");
$stmt->bind_param("ssi", $email, $full_name, $user_id);

// Εκτέλεση του ερωτήματος
if ($stmt->execute()) {
    echo "Τα στοιχεία του χρήστη ενημερώθηκαν επιτυχώς";
} else {
    echo "Σφάλμα: " . $stmt->error;
}

// Κλείσιμο σύνδεσης
$stmt->close();
$conn->close();</code></pre>
    
    <h5>Παράδειγμα Φόρμας Ενημέρωσης με Προσυμπληρωμένα Στοιχεία</h5>
    <pre><code>&lt;?php
// update_form.php - Φόρμα για την ενημέρωση στοιχείων χρήστη

// Σύνδεση με τη βάση δεδομένων
$conn = new mysqli("localhost", "username", "password", "database_name");

// Έλεγχος σύνδεσης
if ($conn->connect_error) {
    die("Η σύνδεση απέτυχε: " . $conn->connect_error);
}

// Λήψη του ID του χρήστη από το URL
$user_id = $_GET['id'];

// Ανάκτηση των τρεχόντων στοιχείων του χρήστη
$stmt = $conn->prepare("SELECT id, username, email, full_name FROM users WHERE id = ?");
$stmt->bind_param("i", $user_id);
$stmt->execute();
$result = $stmt->get_result();

if ($result->num_rows > 0) {
    $user = $result->fetch_assoc();
} else {
    die("Ο χρήστης δεν βρέθηκε");
}

// Κλείσιμο του statement
$stmt->close();
$conn->close();
?&gt;

&lt;!-- Φόρμα με προσυμπληρωμένα τα τρέχοντα στοιχεία --&gt;
&lt;form action="update.php" method="POST"&gt;
    &lt;input type="hidden" name="id" value="&lt;?php echo $user['id']; ?&gt;"&gt;
    
    &lt;div&gt;
        &lt;label for="username"&gt;Όνομα Χρήστη:&lt;/label&gt;
        &lt;input type="text" id="username" name="username" value="&lt;?php echo $user['username']; ?&gt;" disabled&gt;
        &lt;small&gt;Το όνομα χρήστη δεν μπορεί να αλλάξει&lt;/small&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        &lt;label for="email"&gt;Email:&lt;/label&gt;
        &lt;input type="email" id="email" name="email" value="&lt;?php echo $user['email']; ?&gt;" required&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        &lt;label for="full_name"&gt;Πλήρες Όνομα:&lt;/label&gt;
        &lt;input type="text" id="full_name" name="full_name" value="&lt;?php echo $user['full_name']; ?&gt;"&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Ενημέρωση Στοιχείων&lt;/button&gt;
&lt;/form&gt;</code></pre>
    
    <h4>4. Delete (Διαγραφή) - Αφαίρεση Δεδομένων</h4>
    <p>Η λειτουργία Delete χρησιμοποιείται για την αφαίρεση εγγραφών από τη βάση δεδομένων. Είναι σημαντικό να υπάρχει επιβεβαίωση από τον χρήστη πριν από την εκτέλεση μιας διαγραφής, καθώς αυτή η ενέργεια είναι συνήθως μη αναστρέψιμη.</p>
    
    <h5>Παράδειγμα με PDO</h5>
    <pre><code>// delete.php - Διαγραφή χρήστη

// Λήψη του ID του χρήστη από το URL
$user_id = $_GET['id'];

try {
    // Σύνδεση με τη βάση δεδομένων
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Προετοιμασία ερωτήματος
    $stmt = $conn->prepare("DELETE FROM users WHERE id = :id");
    
    // Εκτέλεση του ερωτήματος
    $stmt->execute([':id' => $user_id]);
    
    // Έλεγχος αν διαγράφηκε κάποια εγγραφή
    if ($stmt->rowCount() > 0) {
        echo "Ο χρήστης διαγράφηκε επιτυχώς";
    } else {
        echo "Δεν βρέθηκε χρήστης με αυτό το ID";
    }
} catch(PDOException $e) {
    echo "Σφάλμα: " . $e->getMessage();
}</code></pre>
    
    <h5>Παράδειγμα Σελίδας Επιβεβαίωσης Διαγραφής</h5>
    <pre><code>&lt;!-- delete_confirm.php - Σελίδα επιβεβαίωσης διαγραφής --&gt;
&lt;?php
// Λήψη του ID του χρήστη από το URL
$user_id = $_GET['id'];

// Σύνδεση με τη βάση δεδομένων
$conn = new mysqli("localhost", "username", "password", "database_name");

// Έλεγχος σύνδεσης
if ($conn->connect_error) {
    die("Η σύνδεση απέτυχε: " . $conn->connect_error);
}

// Ανάκτηση των στοιχείων του χρήστη
$stmt = $conn->prepare("SELECT username, email FROM users WHERE id = ?");
$stmt->bind_param("i", $user_id);
$stmt->execute();
$result = $stmt->get_result();

if ($result->num_rows > 0) {
    $user = $result->fetch_assoc();
} else {
    die("Ο χρήστης δεν βρέθηκε");
}

// Κλείσιμο του statement και της σύνδεσης
$stmt->close();
$conn->close();
?&gt;

&lt;h2&gt;Επιβεβαίωση Διαγραφής&lt;/h2&gt;
&lt;p&gt;Είστε βέβαιοι ότι θέλετε να διαγράψετε τον παρακάτω χρήστη;&lt;/p&gt;

&lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Όνομα Χρήστη:&lt;/strong&gt; &lt;?php echo $user['username']; ?&gt;&lt;/p&gt;
    &lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt; &lt;?php echo $user['email']; ?&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;a href="delete.php?id=&lt;?php echo $user_id; ?&gt;" style="color: red;"&gt;Ναι, Διαγραφή&lt;/a&gt;
    &lt;a href="read_all.php"&gt;Όχι, Ακύρωση&lt;/a&gt;
&lt;/div&gt;</code></pre>
    
    <h3>Ολοκληρωμένο Παράδειγμα CRUD</h3>
    <p>Συνήθως, σε μια πραγματική εφαρμογή, οι λειτουργίες CRUD είναι πιο οργανωμένες και συνδυασμένες σε ένα σύστημα. Ας δούμε ένα απλοποιημένο παράδειγμα μιας σελίδας που εμφανίζει μια λίστα χρηστών με επιλογές για προβολή, επεξεργασία και διαγραφή.</p>
    
    <pre><code>&lt;!-- users_list.php - Λίστα χρηστών με ενέργειες CRUD --&gt;
&lt;?php
// Σύνδεση με τη βάση δεδομένων
$conn = new mysqli("localhost", "username", "password", "database_name");

// Έλεγχος σύνδεσης
if ($conn->connect_error) {
    die("Η σύνδεση απέτυχε: " . $conn->connect_error);
}

// Εκτέλεση ερωτήματος για ανάκτηση όλων των χρηστών
$sql = "SELECT id, username, email, full_name FROM users";
$result = $conn->query($sql);
?&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Διαχείριση Χρηστών&lt;/title&gt;
    &lt;style&gt;
        table {
            width: 100%;
            border-collapse: collapse;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .actions a {
            margin-right: 10px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Διαχείριση Χρηστών&lt;/h1&gt;
    
    &lt;a href="create_form.html"&gt;Προσθήκη Νέου Χρήστη&lt;/a&gt;
    
    &lt;h2&gt;Λίστα Χρηστών&lt;/h2&gt;
    
    &lt;?php if ($result->num_rows > 0): ?&gt;
        &lt;table&gt;
            &lt;tr&gt;
                &lt;th&gt;ID&lt;/th&gt;
                &lt;th&gt;Όνομα Χρήστη&lt;/th&gt;
                &lt;th&gt;Email&lt;/th&gt;
                &lt;th&gt;Πλήρες Όνομα&lt;/th&gt;
                &lt;th&gt;Ενέργειες&lt;/th&gt;
            &lt;/tr&gt;
            
            &lt;?php while($row = $result->fetch_assoc()): ?&gt;
                &lt;tr&gt;
                    &lt;td&gt;&lt;?php echo $row["id"]; ?&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;?php echo $row["username"]; ?&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;?php echo $row["email"]; ?&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;?php echo $row["full_name"]; ?&gt;&lt;/td&gt;
                    &lt;td class="actions"&gt;
                        &lt;a href="read_single.php?id=&lt;?php echo $row["id"]; ?&gt;"&gt;Προβολή&lt;/a&gt;
                        &lt;a href="update_form.php?id=&lt;?php echo $row["id"]; ?&gt;"&gt;Επεξεργασία&lt;/a&gt;
                        &lt;a href="delete_confirm.php?id=&lt;?php echo $row["id"]; ?&gt;" style="color: red;"&gt;Διαγραφή&lt;/a&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;?php endwhile; ?&gt;
        &lt;/table&gt;
    &lt;?php else: ?&gt;
        &lt;p&gt;Δεν βρέθηκαν χρήστες στη βάση δεδομένων.&lt;/p&gt;
    &lt;?php endif; ?&gt;
    
&lt;/body&gt;
&lt;/html&gt;

&lt;?php
// Κλείσιμο σύνδεσης
$conn->close();
?&gt;</code></pre>
    
    <h3>Βέλτιστες Πρακτικές για τις Λειτουργίες CRUD</h3>
    <ol>
        <li><strong>Χρησιμοποιείτε πάντα προετοιμασμένες δηλώσεις</strong> για την αποφυγή επιθέσεων SQL injection</li>
        <li><strong>Επικυρώνετε και καθαρίζετε τα δεδομένα εισόδου</strong> από τους χρήστες πριν τα εισάγετε στη βάση δεδομένων</li>
        <li><strong>Χειρίζεστε τα σφάλματα κατάλληλα</strong> και παρέχετε χρήσιμα μηνύματα σφάλματος στους χρήστες</li>
        <li><strong>Χρησιμοποιείτε συναλλαγές (transactions)</strong> για πολύπλοκες λειτουργίες που περιλαμβάνουν πολλαπλές εισαγωγές/ενημερώσεις</li>
        <li><strong>Υλοποιείτε μηχανισμούς ασφαλείας</strong> για να διασφαλίσετε ότι οι χρήστες έχουν πρόσβαση μόνο στα δεδομένα που επιτρέπεται</li>
        <li><strong>Αποφεύγετε τη διαγραφή δεδομένων</strong> όταν είναι δυνατόν - συχνά είναι καλύτερο να επισημάνετε εγγραφές ως ανενεργές</li>
        <li><strong>Διατηρείτε αρχεία καταγραφής (logs)</strong> των σημαντικών λειτουργιών για λόγους ελέγχου και ασφάλειας</li>
    </ol>
    
    <h3>Διαχωρισμός Επιχειρηματικής Λογικής από την Πρόσβαση στα Δεδομένα</h3>
    <p>Για πιο εύκολη συντήρηση και επεκτασιμότητα του κώδικα, είναι καλή πρακτική να διαχωρίζετε τις λειτουργίες CRUD από την επιχειρηματική λογική της εφαρμογής σας. Ένας τρόπος για να το κάνετε αυτό είναι με τη χρήση μοντέλων ή κλάσεων που περιέχουν τις λειτουργίες CRUD.</p>
    
    <h4>Παράδειγμα Κλάσης User με Λειτουργίες CRUD</h4>
    <pre><code>// User.php - Κλάση για τη διαχείριση χρηστών
class User {
    // Ιδιότητες βάσης δεδομένων
    private $conn;
    private $table = 'users';
    
    // Ιδιότητες χρήστη
    public $id;
    public $username;
    public $email;
    public $full_name;
    
    // Constructor με σύνδεση στη βάση δεδομένων
    public function __construct($db) {
        $this->conn = $db;
    }
    
    // Μέθοδος Create - Δημιουργία νέου χρήστη
    public function create() {
        // Ερώτημα
        $query = "INSERT INTO " . $this->table . " 
                  SET username = :username, 
                      email = :email, 
                      full_name = :full_name";
        
        // Προετοιμασία statement
        $stmt = $this->conn->prepare($query);
        
        // Καθαρισμός δεδομένων
        $this->username = htmlspecialchars(strip_tags($this->username));
        $this->email = htmlspecialchars(strip_tags($this->email));
        $this->full_name = htmlspecialchars(strip_tags($this->full_name));
        
        // Σύνδεση παραμέτρων
        $stmt->bindParam(':username', $this->username);
        $stmt->bindParam(':email', $this->email);
        $stmt->bindParam(':full_name', $this->full_name);
        
        // Εκτέλεση ερωτήματος
        if($stmt->execute()) {
            return true;
        }
        
        return false;
    }
    
    // Μέθοδος Read - Ανάκτηση όλων των χρηστών
    public function read() {
        // Ερώτημα
        $query = "SELECT id, username, email, full_name 
                  FROM " . $this->table . " 
                  ORDER BY id";
        
        // Προετοιμασία statement
        $stmt = $this->conn->prepare($query);
        
        // Εκτέλεση ερωτήματος
        $stmt->execute();
        
        return $stmt;
    }
    
    // Μέθοδος Read One - Ανάκτηση ενός χρήστη
    public function readOne() {
        // Ερώτημα
        $query = "SELECT id, username, email, full_name 
                  FROM " . $this->table . " 
                  WHERE id = :id 
                  LIMIT 0,1";
        
        // Προετοιμασία statement
        $stmt = $this->conn->prepare($query);
        
        // Σύνδεση παραμέτρου
        $stmt->bindParam(':id', $this->id);
        
        // Εκτέλεση ερωτήματος
        $stmt->execute();
        
        // Λήψη εγγραφής
        $row = $stmt->fetch(PDO::FETCH_ASSOC);
        
        // Ορισμός ιδιοτήτων
        if($row) {
            $this->id = $row['id'];
            $this->username = $row['username'];
            $this->email = $row['email'];
            $this->full_name = $row['full_name'];
            return true;
        }
        
        return false;
    }
    
    // Μέθοδος Update - Ενημέρωση χρήστη
    public function update() {
        // Ερώτημα
        $query = "UPDATE " . $this->table . " 
                  SET email = :email, 
                      full_name = :full_name 
                  WHERE id = :id";
        
        // Προετοιμασία statement
        $stmt = $this->conn->prepare($query);
        
        // Καθαρισμός δεδομένων
        $this->id = htmlspecialchars(strip_tags($this->id));
        $this->email = htmlspecialchars(strip_tags($this->email));
        $this->full_name = htmlspecialchars(strip_tags($this->full_name));
        
        // Σύνδεση παραμέτρων
        $stmt->bindParam(':id', $this->id);
        $stmt->bindParam(':email', $this->email);
        $stmt->bindParam(':full_name', $this->full_name);
        
        // Εκτέλεση ερωτήματος
        if($stmt->execute()) {
            return true;
        }
        
        return false;
    }
    
    // Μέθοδος Delete - Διαγραφή χρήστη
    public function delete() {
        // Ερώτημα
        $query = "DELETE FROM " . $this->table . " WHERE id = :id";
        
        // Προετοιμασία statement
        $stmt = $this->conn->prepare($query);
        
        // Καθαρισμός id
        $this->id = htmlspecialchars(strip_tags($this->id));
        
        // Σύνδεση παραμέτρου
        $stmt->bindParam(':id', $this->id);
        
        // Εκτέλεση ερωτήματος
        if($stmt->execute()) {
            return true;
        }
        
        return false;
    }
}</code></pre>
    
    <h4>Παράδειγμα Χρήσης της Κλάσης User</h4>
    <pre><code>// Αρχείο σύνδεσης με τη βάση δεδομένων
require_once 'database.php';

// Αρχείο της κλάσης User
require_once 'User.php';

// Σύνδεση με τη βάση δεδομένων
$database = new Database();
$db = $database->connect();

// Δημιουργία αντικειμένου User
$user = new User($db);

// Παράδειγμα Δημιουργίας Χρήστη
$user->username = 'newuser';
$user->email = 'newuser@example.com';
$user->full_name = 'New User';

if($user->create()) {
    echo "Ο χρήστης δημιουργήθηκε επιτυχώς.";
} else {
    echo "Δεν ήταν δυνατή η δημιουργία του χρήστη.";
}

// Παράδειγμα Ανάκτησης Όλων των Χρηστών
$result = $user->read();
$num = $result->rowCount();

if($num > 0) {
    $users_arr = array();
    
    while($row = $result->fetch(PDO::FETCH_ASSOC)) {
        extract($row);
        
        $user_item = array(
            'id' => $id,
            'username' => $username,
            'email' => $email,
            'full_name' => $full_name
        );
        
        array_push($users_arr, $user_item);
    }
    
    echo json_encode($users_arr);
} else {
    echo json_encode(array('message' => 'Δεν βρέθηκαν χρήστες.'));
}</code></pre>
    
    <h3>Συμπέρασμα</h3>
    <p>Οι λειτουργίες CRUD είναι θεμελιώδεις για τη δημιουργία διαδικτυακών εφαρμογών που χρησιμοποιούν βάσεις δεδομένων. Παρέχουν τη βασική λειτουργικότητα για την αλληλεπίδραση με τα δεδομένα της εφαρμογής σας, επιτρέποντας τη δημιουργία, ανάγνωση, ενημέρωση και διαγραφή εγγραφών.</p>
    
    <p>Σε αυτήν την ενότητα, μάθαμε πώς να υλοποιούμε τις βασικές λειτουργίες CRUD με PHP και MySQL, χρησιμοποιώντας τόσο MySQLi όσο και PDO. Καλύψαμε τις βασικές λειτουργίες για τη διαχείριση δεδομένων, την ενσωμάτωσή τους σε ένα ολοκληρωμένο σύστημα και τις βέλτιστες πρακτικές για ασφαλή και αποτελεσματική διαχείριση δεδομένων.</p>
    
    <p>Στην επόμενη ενότητα, θα εξερευνήσουμε πιο αναλυτικά τις Προετοιμασμένες Δηλώσεις και πώς αυτές μπορούν να χρησιμοποιηθούν για την προστασία της εφαρμογής σας από κοινές επιθέσεις ασφαλείας.</p>
</section>

<section id="prepared-statements">
    <h2>5. Προετοιμασμένες Δηλώσεις</h2>
    
    <p>Οι προετοιμασμένες δηλώσεις (prepared statements) είναι ένα από τα πιο σημαντικά εργαλεία για την ασφαλή εκτέλεση ερωτημάτων SQL. Επιτρέπουν τον διαχωρισμό της SQL σύνταξης από τα δεδομένα, παρέχοντας έτσι προστασία από επιθέσεις SQL injection και βελτιώνοντας την απόδοση για επαναλαμβανόμενα ερωτήματα.</p>
    
    <h3>Τι είναι οι Προετοιμασμένες Δηλώσεις;</h3>
    <p>Οι προετοιμασμένες δηλώσεις είναι SQL δηλώσεις που προετοιμάζονται εκ των προτέρων και μπορούν να παραμετροποιηθούν. Η διαδικασία λειτουργεί σε δύο βήματα:</p>
    
    <ol>
        <li><strong>Προετοιμασία:</strong> Το ερώτημα SQL αποστέλλεται στον διακομιστή MySQL με σύμβολα παραμέτρων (placeholders) στη θέση των πραγματικών τιμών</li>
        <li><strong>Εκτέλεση:</strong> Οι πραγματικές τιμές αποστέλλονται στον διακομιστή και συνδέονται με τις παραμέτρους</li>
    </ol>
    
    <h3>Πλεονεκτήματα των Προετοιμασμένων Δηλώσεων</h3>
    <ul>
        <li><strong>Ασφάλεια:</strong> Προστασία από επιθέσεις SQL injection, καθώς τα δεδομένα διαχωρίζονται από τον κώδικα SQL</li>
        <li><strong>Απόδοση:</strong> Βελτιωμένη απόδοση για επαναλαμβανόμενα ερωτήματα, καθώς το ερώτημα αναλύεται και βελτιστοποιείται μόνο μία φορά</li>
        <li><strong>Ευαναγνωσιμότητα:</strong> Ο κώδικας γίνεται πιο καθαρός και ευανάγνωστος</li>
        <li><strong>Αυτόματη διαφυγή (escaping):</strong> Δεν χρειάζεται χειροκίνητη διαφυγή των ειδικών χαρακτήρων</li>
    </ul>
    
    <h3>Προετοιμασμένες Δηλώσεις με MySQLi</h3>
    <p>Η MySQLi παρέχει τη δυνατότητα χρήσης προετοιμασμένων δηλώσεων τόσο στο αντικειμενοστρεφές όσο και στο διαδικαστικό στυλ.</p>
    
    <h4>Αντικειμενοστρεφές Στυλ</h4>
    <pre><code>// Σύνδεση με τη βάση δεδομένων
$conn = new mysqli("localhost", "username", "password", "database_name");

// Έλεγχος σύνδεσης
if ($conn->connect_error) {
    die("Η σύνδεση απέτυχε: " . $conn->connect_error);
}

// 1. Προετοιμασία του ερωτήματος με σύμβολα παραμέτρων
$stmt = $conn->prepare("INSERT INTO users (username, email, password) VALUES (?, ?, ?)");

// 2. Σύνδεση των μεταβλητών με τις παραμέτρους
// s = string, i = integer, d = double, b = blob
$username = "johndoe";
$email = "john@example.com";
$password = password_hash("password123", PASSWORD_DEFAULT);

$stmt->bind_param("sss", $username, $email, $password);

// 3. Εκτέλεση του ερωτήματος
$stmt->execute();

echo "Νέος χρήστης δημιουργήθηκε επιτυχώς";

// 4. Κλείσιμο του statement και της σύνδεσης
$stmt->close();
$conn->close();</code></pre>
    
    <h4>Διαδικαστικό Στυλ</h4>
    <pre><code>// Σύνδεση με τη βάση δεδομένων
$conn = mysqli_connect("localhost", "username", "password", "database_name");

// Έλεγχος σύνδεσης
if (!$conn) {
    die("Η σύνδεση απέτυχε: " . mysqli_connect_error());
}

// 1. Προετοιμασία του ερωτήματος
$stmt = mysqli_prepare($conn, "INSERT INTO users (username, email, password) VALUES (?, ?, ?)");

// 2. Σύνδεση των μεταβλητών με τις παραμέτρους
$username = "johndoe";
$email = "john@example.com";
$password = password_hash("password123", PASSWORD_DEFAULT);

mysqli_stmt_bind_param($stmt, "sss", $username, $email, $password);

// 3. Εκτέλεση του ερωτήματος
mysqli_stmt_execute($stmt);

echo "Νέος χρήστης δημιουργήθηκε επιτυχώς";

// 4. Κλείσιμο του statement και της σύνδεσης
mysqli_stmt_close($stmt);
mysqli_close($conn);</code></pre>
    
    <div class="callout">
        <p><strong>Σημείωση:</strong> Στη συνάρτηση <code>bind_param()</code>, ο πρώτος παράμετρος καθορίζει τους τύπους των μεταβλητών:</p>
        <ul>
            <li><strong>"s"</strong>: string (συμβολοσειρά)</li>
            <li><strong>"i"</strong>: integer (ακέραιος)</li>
            <li><strong>"d"</strong>: double (αριθμός κινητής υποδιαστολής)</li>
            <li><strong>"b"</strong>: blob (δυαδικά δεδομένα μεγάλου μήκους)</li>
        </ul>
    </div>
    
    <h3>Προετοιμασμένες Δηλώσεις με PDO</h3>
    <p>Η PDO προσφέρει δύο τρόπους για τη χρήση προετοιμασμένων δηλώσεων: με ερωτηματικά (?) ή με ονομαστικές παραμέτρους (:name).</p>
    
    <h4>Χρήση Ερωτηματικών (?)</h4>
    <pre><code>try {
    // Σύνδεση με τη βάση δεδομένων
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    
    // Ρύθμιση της PDO για να πετάει εξαιρέσεις σε περίπτωση σφαλμάτων
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // 1. Προετοιμασία του ερωτήματος με ερωτηματικά
    $stmt = $conn->prepare("INSERT INTO users (username, email, password) VALUES (?, ?, ?)");
    
    // 2. Σύνδεση των μεταβλητών με τις παραμέτρους και εκτέλεση
    $username = "johndoe";
    $email = "john@example.com";
    $password = password_hash("password123", PASSWORD_DEFAULT);
    
    $stmt->execute([$username, $email, $password]);
    
    echo "Νέος χρήστης δημιουργήθηκε επιτυχώς";
    
} catch(PDOException $e) {
    echo "Σφάλμα: " . $e->getMessage();
}</code></pre>
    
    <h4>Χρήση Ονομαστικών Παραμέτρων (:name)</h4>
    <pre><code>try {
    // Σύνδεση με τη βάση δεδομένων
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    
    // Ρύθμιση της PDO για να πετάει εξαιρέσεις σε περίπτωση σφαλμάτων
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // 1. Προετοιμασία του ερωτήματος με ονομαστικές παραμέτρους
    $stmt = $conn->prepare("INSERT INTO users (username, email, password) VALUES (:username, :email, :password)");
    
    // 2. Σύνδεση των μεταβλητών με τις παραμέτρους και εκτέλεση
    $username = "johndoe";
    $email = "john@example.com";
    $password = password_hash("password123", PASSWORD_DEFAULT);
    
    $stmt->bindParam(':username', $username);
    $stmt->bindParam(':email', $email);
    $stmt->bindParam(':password', $password);
    
    // 3. Εκτέλεση του ερωτήματος
    $stmt->execute();
    
    echo "Νέος χρήστης δημιουργήθηκε επιτυχώς";
    
} catch(PDOException $e) {
    echo "Σφάλμα: " . $e->getMessage();
}</code></pre>
    
    <div class="callout">
        <p><strong>Συμβουλή:</strong> Η χρήση ονομαστικών παραμέτρων της PDO κάνει τον κώδικα πιο ευανάγνωστο και λιγότερο επιρρεπή σε λάθη, ειδικά σε πολύπλοκα ερωτήματα με πολλές παραμέτρους.</p>
    </div>
    
    <h4>Εναλλακτικός Τρόπος Εκτέλεσης με Πίνακα Παραμέτρων</h4>
    <pre><code>try {
    // Σύνδεση με τη βάση δεδομένων
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Προετοιμασία του ερωτήματος
    $stmt = $conn->prepare("INSERT INTO users (username, email, password) VALUES (:username, :email, :password)");
    
    // Εκτέλεση με πίνακα παραμέτρων
    $stmt->execute([
        ':username' => 'johndoe',
        ':email' => 'john@example.com',
        ':password' => password_hash('password123', PASSWORD_DEFAULT)
    ]);
    
    echo "Νέος χρήστης δημιουργήθηκε επιτυχώς";
    
} catch(PDOException $e) {
    echo "Σφάλμα: " . $e->getMessage();
}</code></pre>
    
    <h3>Ανάκτηση Δεδομένων με Προετοιμασμένες Δηλώσεις</h3>
    <p>Οι προετοιμασμένες δηλώσεις δεν χρησιμοποιούνται μόνο για την εισαγωγή δεδομένων, αλλά και για την ανάκτηση δεδομένων από τη βάση.</p>
    
    <h4>Παράδειγμα με MySQLi</h4>
    <pre><code>// Σύνδεση με τη βάση δεδομένων
$conn = new mysqli("localhost", "username", "password", "database_name");

// Έλεγχος σύνδεσης
if ($conn->connect_error) {
    die("Η σύνδεση απέτυχε: " . $conn->connect_error);
}

// Προετοιμασία του ερωτήματος
$stmt = $conn->prepare("SELECT id, username, email FROM users WHERE id = ?");

// Σύνδεση της παραμέτρου
$user_id = 1;
$stmt->bind_param("i", $user_id);

// Εκτέλεση του ερωτήματος
$stmt->execute();

// Σύνδεση των αποτελεσμάτων με μεταβλητές
$stmt->bind_result($id, $username, $email);

// Λήψη των αποτελεσμάτων
if ($stmt->fetch()) {
    echo "ID: " . $id . "<br>";
    echo "Username: " . $username . "<br>";
    echo "Email: " . $email . "<br>";
} else {
    echo "Δεν βρέθηκαν αποτελέσματα";
}

// Κλείσιμο του statement και της σύνδεσης
$stmt->close();
$conn->close();</code></pre>
    
    <h4>Παράδειγμα με PDO</h4>
    <pre><code>try {
    // Σύνδεση με τη βάση δεδομένων
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Προετοιμασία του ερωτήματος
    $stmt = $conn->prepare("SELECT id, username, email FROM users WHERE id = :id");
    
    // Εκτέλεση με παράμετρο
    $user_id = 1;
    $stmt->execute([':id' => $user_id]);
    
    // Λήψη των αποτελεσμάτων
    $user = $stmt->fetch(PDO::FETCH_ASSOC);
    
    if ($user) {
        echo "ID: " . $user['id'] . "<br>";
        echo "Username: " . $user['username'] . "<br>";
        echo "Email: " . $user['email'] . "<br>";
    } else {
        echo "Δεν βρέθηκαν αποτελέσματα";
    }
    
} catch(PDOException $e) {
    echo "Σφάλμα: " . $e->getMessage();
}</code></pre>
    
    <h3>Διαχείριση Πολλαπλών Αποτελεσμάτων</h3>
    <p>Όταν το ερώτημά σας επιστρέφει πολλαπλές εγγραφές, μπορείτε να τις επεξεργαστείτε χρησιμοποιώντας βρόχους.</p>
    
    <h4>Χρήση της MySQLi</h4>
    <pre><code>// Σύνδεση με τη βάση δεδομένων
$conn = new mysqli("localhost", "username", "password", "database_name");

// Προετοιμασία του ερωτήματος
$stmt = $conn->prepare("SELECT id, username, email FROM users WHERE status = ?");

// Σύνδεση της παραμέτρου
$status = "active";
$stmt->bind_param("s", $status);

// Εκτέλεση του ερωτήματος
$stmt->execute();

// Λήψη των αποτελεσμάτων
$result = $stmt->get_result();

// Εμφάνιση των αποτελεσμάτων σε πίνακα HTML
if ($result->num_rows > 0) {
    echo "<table border='1'>
          <tr>
            <th>ID</th>
            <th>Username</th>
            <th>Email</th>
          </tr>";
    
    while ($row = $result->fetch_assoc()) {
        echo "<tr>
                <td>" . $row["id"] . "</td>
                <td>" . $row["username"] . "</td>
                <td>" . $row["email"] . "</td>
              </tr>";
    }
    
    echo "</table>";
} else {
    echo "Δεν βρέθηκαν αποτελέσματα";
}

// Κλείσιμο του statement και της σύνδεσης
$stmt->close();
$conn->close();</code></pre>
    
    <h4>Χρήση της PDO</h4>
    <pre><code>try {
    // Σύνδεση με τη βάση δεδομένων
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Προετοιμασία του ερωτήματος
    $stmt = $conn->prepare("SELECT id, username, email FROM users WHERE status = :status");
    
    // Εκτέλεση με παράμετρο
    $status = "active";
    $stmt->execute([':status' => $status]);
    
    // Εμφάνιση των αποτελεσμάτων σε πίνακα HTML
    if ($stmt->rowCount() > 0) {
        echo "<table border='1'>
              <tr>
                <th>ID</th>
                <th>Username</th>
                <th>Email</th>
              </tr>";
        
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            echo "<tr>
                    <td>" . $row["id"] . "</td>
                    <td>" . $row["username"] . "</td>
                    <td>" . $row["email"] . "</td>
                  </tr>";
        }
        
        echo "</table>";
    } else {
        echo "Δεν βρέθηκαν αποτελέσματα";
    }
    
} catch(PDOException $e) {
    echo "Σφάλμα: " . $e->getMessage();
}</code></pre>
    
    <h3>Προστασία από SQL Injection</h3>
    <p>Η SQL injection είναι μια συχνή τεχνική επίθεσης όπου κακόβουλος κώδικας εισάγεται σε ερωτήματα SQL μέσω της εισόδου των χρηστών. Οι προετοιμασμένες δηλώσεις προστατεύουν από αυτές τις επιθέσεις διαχωρίζοντας τον κώδικα SQL από τα δεδομένα.</p>
    
    <h4>Παράδειγμα Ευάλωτου Κώδικα</h4>
    <pre><code>// ΜΗΝ ΧΡΗΣΙΜΟΠΟΙΕΙΤΕ ΑΥΤΟΝ ΤΟΝ ΚΩΔΙΚΑ! ΕΙΝΑΙ ΕΥΑΛΩΤΟΣ ΣΕ SQL INJECTION!
$username = $_POST['username'];
$password = $_POST['password'];

$sql = "SELECT * FROM users WHERE username = '$username' AND password = '$password'";
$result = $conn->query($sql);

// Αν κάποιος εισάγει username: ' OR '1'='1 και password: ' OR '1'='1
// Το ερώτημα θα γίνει: SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '' OR '1'='1'
// Αυτό θα επιστρέψει ΟΛΟΥΣ τους χρήστες!</code></pre>
    
    <h4>Ασφαλής Κώδικας με Προετοιμασμένες Δηλώσεις</h4>
    <pre><code>// Ασφαλής τρόπος με MySQLi
$stmt = $conn->prepare("SELECT * FROM users WHERE username = ? AND password = ?");
$stmt->bind_param("ss", $username, $password);
$stmt->execute();
$result = $stmt->get_result();

// Ή με PDO
$stmt = $conn->prepare("SELECT * FROM users WHERE username = :username AND password = :password");
$stmt->execute([
    ':username' => $username,
    ':password' => $password
]);
$result = $stmt->fetch(PDO::FETCH_ASSOC);</code></pre>
    
    <div class="callout warning">
        <p><strong>ΣΗΜΑΝΤΙΚΟ:</strong> Ποτέ μην αποθηκεύετε κωδικούς πρόσβασης σε απλό κείμενο. Χρησιμοποιείτε πάντα συναρτήσεις κατακερματισμού (hashing) όπως <code>password_hash()</code> και <code>password_verify()</code>.</p>
        <pre><code>// Σωστός τρόπος ελέγχου ταυτότητας
$stmt = $conn->prepare("SELECT id, username, password FROM users WHERE username = ?");
$stmt->bind_param("s", $username);
$stmt->execute();
$result = $stmt->get_result();
$user = $result->fetch_assoc();

if ($user && password_verify($password, $user['password'])) {
    // Επιτυχής σύνδεση
} else {
    // Αποτυχημένη σύνδεση
}</code></pre>
    </div>
    
    <h3>Βέλτιστες Πρακτικές για Προετοιμασμένες Δηλώσεις</h3>
    <ol>
        <li><strong>Πάντα χρησιμοποιείτε προετοιμασμένες δηλώσεις</strong> για ερωτήματα που περιλαμβάνουν είσοδο χρήστη</li>
        <li><strong>Ελέγχετε τα σφάλματα</strong> μετά την προετοιμασία και την εκτέλεση των δηλώσεων</li>
        <li><strong>Κλείνετε τα statements</strong> μετά τη χρήση τους για την απελευθέρωση πόρων</li>
        <li><strong>Χρησιμοποιείτε τους σωστούς τύπους παραμέτρων</strong> στην <code>bind_param()</code> της MySQLi</li>
        <li><strong>Προτιμήστε ονομαστικές παραμέτρους</strong> στην PDO για καλύτερη αναγνωσιμότητα</li>
        <li><strong>Μην συνενώνετε δυναμικά ονόματα πινάκων ή στηλών</strong> - αυτά δεν μπορούν να παραμετροποιηθούν με προετοιμασμένες δηλώσεις</li>
    </ol>
    
    <h4>Παράδειγμα Χρήσης Προετοιμασμένων Δηλώσεων σε Ολοκληρωμένη Φόρμα</h4>
    <pre><code>&lt;!-- login_form.html - Φόρμα σύνδεσης --&gt;
&lt;form action="login_process.php" method="POST"&gt;
    &lt;div&gt;
        &lt;label for="username"&gt;Όνομα Χρήστη:&lt;/label&gt;
        &lt;input type="text" id="username" name="username" required&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        &lt;label for="password"&gt;Κωδικός Πρόσβασης:&lt;/label&gt;
        &lt;input type="password" id="password" name="password" required&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Σύνδεση&lt;/button&gt;
&lt;/form&gt;</code></pre>
    
    <pre><code>&lt;?php
// login_process.php - Επεξεργασία φόρμας σύνδεσης

// Σύνδεση με τη βάση δεδομένων
$conn = new mysqli("localhost", "username", "password", "database_name");

// Έλεγχος σύνδεσης
if ($conn->connect_error) {
    die("Η σύνδεση απέτυχε: " . $conn->connect_error);
}

// Λήψη δεδομένων από τη φόρμα
$username = $_POST['username'];
$password = $_POST['password'];

// Προετοιμασία του ερωτήματος
$stmt = $conn->prepare("SELECT id, username, password FROM users WHERE username = ?");

// Έλεγχος για σφάλματα προετοιμασίας
if (!$stmt) {
    die("Σφάλμα προετοιμασίας: " . $conn->error);
}

// Σύνδεση παραμέτρου
$stmt->bind_param("s", $username);

// Εκτέλεση του ερωτήματος
$stmt->execute();

// Λήψη αποτελέσματος
$result = $stmt->get_result();
$user = $result->fetch_assoc();

// Έλεγχος αν ο χρήστης υπάρχει και ο κωδικός είναι σωστός
if ($user && password_verify($password, $user['password'])) {
    // Επιτυχής σύνδεση
    session_start();
    $_SESSION['user_id'] = $user['id'];
    $_SESSION['username'] = $user['username'];
    
    // Ανακατεύθυνση στην αρχική σελίδα
    header("Location: dashboard.php");
    exit();
} else {
    // Αποτυχημένη σύνδεση
    echo "Λάθος όνομα χρήστη ή κωδικός πρόσβασης";
}

// Κλείσιμο του statement και της σύνδεσης
$stmt->close();
$conn->close();
?&gt;</code></pre>
    
    <h3>Συμπέρασμα</h3>
    <p>Οι προετοιμασμένες δηλώσεις είναι ένα απαραίτητο εργαλείο για κάθε προγραμματιστή που εργάζεται με βάσεις δεδομένων σε PHP. Προσφέρουν σημαντικά πλεονεκτήματα ασφάλειας και απόδοσης, και θα πρέπει να χρησιμοποιούνται συστηματικά για όλα τα ερωτήματα που περιλαμβάνουν είσοδο χρήστη.</p>
    
    <p>Τόσο η MySQLi όσο και η PDO παρέχουν ισχυρή υποστήριξη για προετοιμασμένες δηλώσεις, με την PDO να προσφέρει πρόσθετη ευελιξία μέσω των ονομαστικών παραμέτρων. Η επιλογή μεταξύ των δύο εξαρτάται από τις απαιτήσεις του έργου σας και τις προσωπικές σας προτιμήσεις.
    </p>
</section>

<section id="error-handling">
    <h2>6. Χειρισμός Σφαλμάτων</h2>
    
    <p>Ο αποτελεσματικός χειρισμός σφαλμάτων είναι κρίσιμος για τη δημιουργία αξιόπιστων εφαρμογών PHP που χρησιμοποιούν βάσεις δεδομένων MySQL. Επιτρέπει την ανίχνευση, καταγραφή και διαχείριση προβλημάτων που μπορεί να προκύψουν κατά την εκτέλεση ερωτημάτων στη βάση δεδομένων.</p>
    
    <h3>Βασικές Αρχές Χειρισμού Σφαλμάτων</h3>
    <ul>
        <li><strong>Πρόληψη:</strong> Προσπαθήστε να αποφύγετε τα σφάλματα εκ των προτέρων με καλές πρακτικές προγραμματισμού</li>
        <li><strong>Ανίχνευση:</strong> Ελέγχετε πάντα για πιθανά σφάλματα σε κάθε βήμα</li>
        <li><strong>Αναφορά:</strong> Παρέχετε σαφείς και χρήσιμες πληροφορίες για τυχόν σφάλματα</li>
        <li><strong>Διαχείριση:</strong> Αντιμετωπίστε τα σφάλματα με κατάλληλο τρόπο ώστε η εφαρμογή να συνεχίσει να λειτουργεί ή να τερματιστεί με ασφάλεια</li>
        <li><strong>Καταγραφή:</strong> Διατηρείτε καταγραφές των σφαλμάτων για μελλοντική ανάλυση</li>
    </ul>
    
    <h3>Τύποι Σφαλμάτων στις Βάσεις Δεδομένων</h3>
    <p>Είναι σημαντικό να κατανοήσουμε τους διαφορετικούς τύπους σφαλμάτων που μπορεί να προκύψουν:</p>
    
    <ul>
        <li><strong>Σφάλματα σύνδεσης:</strong> Όταν δεν είναι δυνατή η σύνδεση στη βάση δεδομένων</li>
        <li><strong>Σφάλματα σύνταξης SQL:</strong> Λάθη στη σύνταξη των ερωτημάτων SQL</li>
        <li><strong>Σφάλματα περιορισμών:</strong> Όταν παραβιάζονται περιορισμοί της βάσης (π.χ. μοναδικότητα)</li>
        <li><strong>Σφάλματα δικαιωμάτων:</strong> Όταν ο χρήστης δεν έχει τα απαραίτητα δικαιώματα</li>
        <li><strong>Σφάλματα εκτέλεσης:</strong> Προβλήματα που προκύπτουν κατά την εκτέλεση</li>
    </ul>
    
    <h3>Χειρισμός Σφαλμάτων με MySQLi</h3>
    <p>Η MySQLi παρέχει διάφορους τρόπους για τον χειρισμό σφαλμάτων που μπορεί να προκύψουν κατά την αλληλεπίδραση με τη βάση δεδομένων.</p>
    
    <h4>Αντικειμενοστρεφές Στυλ</h4>
    <pre><code>// Σύνδεση στη βάση δεδομένων
$conn = new mysqli("localhost", "username", "password", "database_name");

// Έλεγχος για σφάλματα σύνδεσης
if ($conn->connect_error) {
    die("Η σύνδεση απέτυχε: " . $conn->connect_error);
}

// Προετοιμασία του ερωτήματος
$stmt = $conn->prepare("INSERT INTO users (username, email) VALUES (?, ?)");

// Έλεγχος για σφάλματα προετοιμασίας
if (!$stmt) {
    die("Σφάλμα προετοιμασίας: " . $conn->error);
}

// Σύνδεση παραμέτρων
$username = "johndoe";
$email = "john@example.com";

if (!$stmt->bind_param("ss", $username, $email)) {
    die("Σφάλμα σύνδεσης παραμέτρων: " . $stmt->error);
}

// Εκτέλεση του ερωτήματος
if (!$stmt->execute()) {
    die("Σφάλμα εκτέλεσης: " . $stmt->error);
}

echo "Η εγγραφή καταχωρήθηκε επιτυχώς!";

$stmt->close();
$conn->close();</code></pre>
    
    <h4>Διαχείριση Σφαλμάτων με try-catch στην MySQLi</h4>
    <p>Παρόλο που η MySQLi δεν χρησιμοποιεί εξαιρέσεις από προεπιλογή, μπορείτε να τις ενεργοποιήσετε με τη ρύθμιση report_mode.</p>
    <pre><code>// Ενεργοποίηση εξαιρέσεων για MySQLi
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);

try {
    // Σύνδεση στη βάση δεδομένων
    $conn = new mysqli("localhost", "username", "password", "database_name");
    
    // Προετοιμασία και εκτέλεση του ερωτήματος
    $stmt = $conn->prepare("INSERT INTO users (username, email) VALUES (?, ?)");
    $username = "johndoe";
    $email = "john@example.com";
    $stmt->bind_param("ss", $username, $email);
    $stmt->execute();
    
    echo "Η εγγραφή καταχωρήθηκε επιτυχώς!";
    
    $stmt->close();
    $conn->close();
} catch (mysqli_sql_exception $e) {
    echo "Σφάλμα MySQL: " . $e->getMessage();
    // Προαιρετικά, καταγραφή του σφάλματος
    error_log("MySQL error: " . $e->getMessage());
}</code></pre>
    
    <h3>Χειρισμός Σφαλμάτων με PDO</h3>
    <p>Η PDO παρέχει ένα πιο συνεπές και αντικειμενοστρεφές μοντέλο για τον χειρισμό σφαλμάτων με τη χρήση εξαιρέσεων.</p>
    
    <pre><code>try {
    // Σύνδεση στη βάση δεδομένων
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    
    // Ρύθμιση της PDO για να πετάει εξαιρέσεις σε περίπτωση σφαλμάτων
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Προετοιμασία και εκτέλεση του ερωτήματος
    $stmt = $conn->prepare("INSERT INTO users (username, email) VALUES (:username, :email)");
    $stmt->execute([
        ':username' => 'johndoe',
        ':email' => 'john@example.com'
    ]);
    
    echo "Η εγγραφή καταχωρήθηκε επιτυχώς!";
    
} catch (PDOException $e) {
    echo "Σφάλμα: " . $e->getMessage();
    
    // Προαιρετικά, καταγραφή του σφάλματος
    error_log("PDO error: " . $e->getMessage());
    
    // Ανάλογα με το περιβάλλον, μπορεί να θέλετε να εμφανίσετε ένα γενικό μήνυμα σφάλματος
    // echo "Παρουσιάστηκε ένα σφάλμα στη βάση δεδομένων. Παρακαλώ δοκιμάστε αργότερα.";
} finally {
    // Ο κώδικας εδώ θα εκτελεστεί ανεξάρτητα από το αν προέκυψε εξαίρεση ή όχι
    // Χρήσιμο για καθαρισμό πόρων
    $conn = null;
}</code></pre>
    
    <h3>Καταγραφή Σφαλμάτων</h3>
    <p>Η καταγραφή σφαλμάτων είναι σημαντική για την αντιμετώπιση προβλημάτων και τη βελτίωση της εφαρμογής σας. Η PHP παρέχει τη συνάρτηση <code>error_log()</code> για την καταγραφή σφαλμάτων.</p>
    
    <pre><code>try {
    // Κώδικας βάσης δεδομένων
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    // ...
} catch (PDOException $e) {
    // Καταγραφή λεπτομερούς μηνύματος σφάλματος για τους διαχειριστές
    error_log("Σφάλμα βάσης δεδομένων: " . $e->getMessage() . " στο αρχείο " . $e->getFile() . " στη γραμμή " . $e->getLine());
    
    // Εμφάνιση φιλικού μηνύματος για τους χρήστες
    echo "Παρουσιάστηκε ένα πρόβλημα κατά την επεξεργασία του αιτήματός σας. Οι διαχειριστές έχουν ενημερωθεί.";
}</code></pre>
    
    <div class="callout">
        <p><strong>Συμβουλή:</strong> Σε περιβάλλον παραγωγής, αποφύγετε την εμφάνιση λεπτομερών μηνυμάτων σφάλματος στους χρήστες, καθώς μπορεί να αποκαλύψουν ευαίσθητες πληροφορίες για τη δομή της βάσης δεδομένων ή την εφαρμογή σας. Αντίθετα, καταγράψτε τα λεπτομερή σφάλματα και εμφανίστε φιλικά μηνύματα στους χρήστες.</p>
    </div>
    
    <h3>Διαχείριση Συγκεκριμένων Σφαλμάτων</h3>
    <p>Διαφορετικά σφάλματα μπορεί να απαιτούν διαφορετική αντιμετώπιση. Ας δούμε μερικά παραδείγματα.</p>
    
    <h4>Διαχείριση Μοναδικών Περιορισμών</h4>
    <pre><code>try {
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    $stmt = $conn->prepare("INSERT INTO users (username, email) VALUES (:username, :email)");
    $stmt->execute([
        ':username' => 'johndoe',
        ':email' => 'john@example.com'
    ]);
    
    echo "Ο χρήστης καταχωρήθηκε επιτυχώς!";
    
} catch (PDOException $e) {
    // Έλεγχος για σφάλμα μοναδικού περιορισμού (Duplicate entry)
    if ($e->getCode() == 23000 && strpos($e->getMessage(), 'Duplicate entry') !== false) {
        if (strpos($e->getMessage(), 'users.username') !== false) {
            echo "Το όνομα χρήστη χρησιμοποιείται ήδη. Παρακαλώ επιλέξτε άλλο.";
        } elseif (strpos($e->getMessage(), 'users.email') !== false) {
            echo "Το email χρησιμοποιείται ήδη. Παρακαλώ χρησιμοποιήστε άλλο ή συνδεθείτε με αυτό.";
        } else {
            echo "Τα στοιχεία που εισαγάγατε χρησιμοποιούνται ήδη.";
        }
    } else {
        // Άλλο σφάλμα
        error_log("Σφάλμα βάσης δεδομένων: " . $e->getMessage());
        echo "Παρουσιάστηκε ένα σφάλμα. Παρακαλώ δοκιμάστε αργότερα.";
    }
}</code></pre>
    
    <h4>Διαχείριση Προβλημάτων Σύνδεσης</h4>
    <pre><code>try {
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Κώδικας βάσης δεδομένων...
    
} catch (PDOException $e) {
    // Έλεγχος για σφάλματα σύνδεσης
    if (strpos($e->getMessage(), 'SQLSTATE[HY000]') !== false) {
        // Καταγραφή προβλήματος
        error_log("Σφάλμα σύνδεσης στη βάση δεδομένων: " . $e->getMessage());
        
        // Εμφάνιση ενός φιλικού μηνύματος
        echo "Δεν είναι δυνατή η σύνδεση στη βάση δεδομένων αυτή τη στιγμή. Παρακαλώ δοκιμάστε αργότερα.";
        
        // Αποστολή ειδοποίησης στους διαχειριστές
        // mail('admin@example.com', 'Πρόβλημα σύνδεσης στη βάση δεδομένων', $e->getMessage());
    } else {
        // Άλλα σφάλματα
        error_log("Σφάλμα βάσης δεδομένων: " . $e->getMessage());
        echo "Παρουσιάστηκε ένα σφάλμα. Παρακαλώ δοκιμάστε αργότερα.";
    }
}</code></pre>
    
    <h3>Χρήση Συναλλαγών για Χειρισμό Σφαλμάτων</h3>
    <p>Οι συναλλαγές (transactions) είναι ένα ισχυρό εργαλείο για τη διασφάλιση της ακεραιότητας των δεδομένων όταν εκτελείτε πολλαπλά ερωτήματα που πρέπει να ολοκληρωθούν όλα με επιτυχία ή κανένα.</p>
    
    <pre><code>try {
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Έναρξη συναλλαγής
    $conn->beginTransaction();
    
    // Εκτέλεση πολλαπλών ερωτημάτων
    $stmt1 = $conn->prepare("INSERT INTO orders (user_id, total_amount) VALUES (?, ?)");
    $stmt1->execute([1, 99.99]);
    $order_id = $conn->lastInsertId();
    
    $stmt2 = $conn->prepare("INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)");
    $stmt2->execute([$order_id, 101, 2, 49.99]);
    $stmt2->execute([$order_id, 102, 1, 0.01]);
    
    // Αν όλα πάνε καλά, γίνεται commit της συναλλαγής
    $conn->commit();
    
    echo "Η παραγγελία καταχωρήθηκε επιτυχώς!";
    
} catch (PDOException $e) {
    // Αν προκύψει σφάλμα, γίνεται rollback της συναλλαγής
    if ($conn->inTransaction()) {
        $conn->rollBack();
    }
    
    error_log("Σφάλμα συναλλαγής: " . $e->getMessage());
    echo "Σφάλμα κατά την καταχώρηση της παραγγελίας. Παρακαλώ δοκιμάστε αργότερα.";
}</code></pre>
    
    <h3>Δημιουργία Κλάσης Χειρισμού Σφαλμάτων</h3>
    <p>Για μεγαλύτερες εφαρμογές, είναι χρήσιμο να δημιουργήσετε μια ξεχωριστή κλάση για τον χειρισμό σφαλμάτων βάσης δεδομένων.</p>
    
    <pre><code>// DatabaseException.php - Προσαρμοσμένη κλάση εξαιρέσεων
class DatabaseException extends Exception {
    protected $query;
    
    public function __construct($message, $query = "", $code = 0, Exception $previous = null) {
        parent::__construct($message, $code, $previous);
        $this->query = $query;
    }
    
    public function getQuery() {
        return $this->query;
    }
    
    public function logError() {
        $errorMsg = sprintf(
            "Σφάλμα βάσης δεδομένων [%s]: %s\nΕρώτημα: %s\nΑρχείο: %s (Γραμμή: %d)",
            $this->code,
            $this->message,
            $this->query,
            $this->getFile(),
            $this->getLine()
        );
        
        error_log($errorMsg);
    }
}

// Database.php - Κλάση διαχείρισης βάσης δεδομένων
class Database {
    private $conn;
    
    public function __construct($host, $dbname, $username, $password) {
        try {
            $this->conn = new PDO("mysql:host=$host;dbname=$dbname", $username, $password);
            $this->conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        } catch (PDOException $e) {
            throw new DatabaseException("Σφάλμα σύνδεσης στη βάση δεδομένων: " . $e->getMessage(), "", $e->getCode(), $e);
        }
    }
    
    public function execute($query, $params = []) {
        try {
            $stmt = $this->conn->prepare($query);
            $stmt->execute($params);
            return $stmt;
        } catch (PDOException $e) {
            throw new DatabaseException($e->getMessage(), $query, $e->getCode(), $e);
        }
    }
    
    public function insert($query, $params = []) {
        $this->execute($query, $params);
        return $this->conn->lastInsertId();
    }
    
    public function select($query, $params = []) {
        $stmt = $this->execute($query, $params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    public function beginTransaction() {
        return $this->conn->beginTransaction();
    }
    
    public function commit() {
        return $this->conn->commit();
    }
    
    public function rollBack() {
        return $this->conn->rollBack();
    }
}

// Παράδειγμα χρήσης
try {
    $db = new Database("localhost", "database_name", "username", "password");
    
    // Εκτέλεση απλού ερωτήματος
    $users = $db->select("SELECT * FROM users WHERE status = ?", ["active"]);
    
    // Εκτέλεση εισαγωγής
    $newUserId = $db->insert("INSERT INTO users (username, email) VALUES (?, ?)", ["johndoe", "john@example.com"]);
    
    echo "Νέος χρήστης με ID: " . $newUserId;
    
} catch (DatabaseException $e) {
    // Καταγραφή του σφάλματος
    $e->logError();
    
    // Εμφάνιση κατάλληλου μηνύματος στον χρήστη
    echo "Παρουσιάστηκε σφάλμα κατά την επεξεργασία του αιτήματός σας.";
}</code></pre>
    
    <h3>Παράδειγμα Ολοκληρωμένης Φόρμας με Χειρισμό Σφαλμάτων</h3>
    <p>Παρακάτω είναι ένα ολοκληρωμένο παράδειγμα φόρμας εγγραφής χρήστη με χειρισμό σφαλμάτων:</p>
    
    <pre><code>&lt;!-- register_form.html --&gt;
&lt;form action="register.php" method="POST"&gt;
    &lt;div&gt;
        &lt;label for="username"&gt;Όνομα Χρήστη:&lt;/label&gt;
        &lt;input type="text" id="username" name="username" required&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        &lt;label for="email"&gt;Email:&lt;/label&gt;
        &lt;input type="email" id="email" name="email" required&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
        &lt;label for="password"&gt;Κωδικός Πρόσβασης:&lt;/label&gt;
        &lt;input type="password" id="password" name="password" required&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Εγγραφή&lt;/button&gt;
&lt;/form&gt;</code></pre>
    
    <pre><code>&lt;?php
// register.php
try {
    // Σύνδεση στη βάση δεδομένων
    $conn = new PDO("mysql:host=localhost;dbname=database_name", "username", "password");
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Λήψη δεδομένων από τη φόρμα
    $username = $_POST['username'];
    $email = $_POST['email'];
    $password = password_hash($_POST['password'], PASSWORD_DEFAULT); // Ασφαλής κρυπτογράφηση
    
    // Έλεγχος αν το όνομα χρήστη υπάρχει ήδη
    $checkStmt = $conn->prepare("SELECT COUNT(*) FROM users WHERE username = ?");
    $checkStmt->execute([$username]);
    
    if ($checkStmt->fetchColumn() > 0) {
        throw new Exception("Το όνομα χρήστη χρησιμοποιείται ήδη.");
    }
    
    // Έλεγχος αν το email υπάρχει ήδη
    $checkStmt = $conn->prepare("SELECT COUNT(*) FROM users WHERE email = ?");
    $checkStmt->execute([$email]);
    
    if ($checkStmt->fetchColumn() > 0) {
        throw new Exception("Το email χρησιμοποιείται ήδη.");
    }
    
    // Εισαγωγή του νέου χρήστη
    $stmt = $conn->prepare("INSERT INTO users (username, email, password) VALUES (?, ?, ?)");
    $stmt->execute([$username, $email, $password]);
    
    // Επιτυχής εγγραφή
    echo "Η εγγραφή ολοκληρώθηκε με επιτυχία!";
    
} catch (PDOException $e) {
    // Χειρισμός σφαλμάτων βάσης δεδομένων
    error_log("Σφάλμα βάσης δεδομένων: " . $e->getMessage());
    
    if ($e->getCode() == 23000) {
        // Παραβίαση περιορισμού μοναδικότητας
        echo "Τα στοιχεία που υποβάλατε χρησιμοποιούνται ήδη.";
    } else {
        // Γενικό σφάλμα
        echo "Παρουσιάστηκε ένα σφάλμα κατά την εγγραφή. Παρακαλώ δοκιμάστε αργότερα.";
    }
} catch (Exception $e) {
    // Χειρισμός άλλων σφαλμάτων (π.χ. έλεγχος μοναδικότητας)
    echo $e->getMessage();
}
?&gt;</code></pre>
    
    <h3>Συμβουλές Χειρισμού Σφαλμάτων σε Περιβάλλον Παραγωγής</h3>
    <ol>
        <li><strong>Απενεργοποιήστε την εμφάνιση σφαλμάτων στον χρήστη</strong> - Χρησιμοποιήστε το <code>display_errors = Off</code> στο php.ini</li>
        <li><strong>Ενεργοποιήστε την καταγραφή σφαλμάτων</strong> - Χρησιμοποιήστε το <code>log_errors = On</code> και <code>error_log = /path/to/error_log</code></li>
        <li><strong>Χρησιμοποιήστε δοκιμασμένες διαδικασίες ανάκαμψης</strong> από συχνά σφάλματα</li>
        <li><strong>Υλοποιήστε ένα σύστημα ειδοποίησης</strong> για κρίσιμα σφάλματα</li>
        <li><strong>Δημιουργήστε φιλικές προς τον χρήστη σελίδες σφάλματος</strong> που παρέχουν χρήσιμες πληροφορίες χωρίς τεχνικές λεπτομέρειες</li>
        <li><strong>Διατηρήστε αναλυτικά αρχεία καταγραφής</strong> με όλες τις απαραίτητες πληροφορίες για την αντιμετώπιση προβλημάτων</li>
    </ol>
    
    <div class="callout warning">
        <p><strong>ΠΡΟΣΟΧΗ:</strong> Σε περιβάλλον ανάπτυξης, τα λεπτομερή μηνύματα σφάλματος είναι χρήσιμα για εντοπισμό προβλημάτων. Σε περιβάλλον παραγωγής, ωστόσο, τα ίδια μηνύματα μπορεί να αποκαλύψουν ευαίσθητες πληροφορίες σε κακόβουλους χρήστες. Πάντα να χρησιμοποιείτε διαφορετικές ρυθμίσεις χειρισμού σφαλμάτων για κάθε περιβάλλον.</p>
    </div>
    
    <h3>Παράδειγμα Ολοκληρωμένου Χειρισμού Σφαλμάτων</h3>
    <p>Το παρακάτω παράδειγμα συνδυάζει πολλές από τις πρακτικές που συζητήθηκαν για να δημιουργήσει ένα ολοκληρωμένο σύστημα χειρισμού σφαλμάτων για μια εφαρμογή PHP-MySQL.</p>
    
    <pre><code>&lt;?php
// config.php - Αρχείο ρυθμίσεων

// Ρυθμίσεις ανάλογα με το περιβάλλον
$environment = 'development'; // 'development' ή 'production'

if ($environment === 'development') {
    // Ρυθμίσεις ανάπτυξης
    ini_set('display_errors', 1);
    ini_set('display_startup_errors', 1);
    error_reporting(E_ALL);
} else {
    // Ρυθμίσεις παραγωγής
    ini_set('display_errors', 0);
    error_reporting(E_ALL);
    ini_set('log_errors', 1);
    ini_set('error_log', __DIR__ . '/logs/error.log');
}

// Ρυθμίσεις βάσης δεδομένων
define('DB_HOST', 'localhost');
define('DB_NAME', 'database_name');
define('DB_USER', 'username');
define('DB_PASS', 'password');
?&gt;</code></pre>
    
    <pre><code>&lt;?php
// ErrorHandler.php - Κλάση διαχείρισης σφαλμάτων

class ErrorHandler {
    // Τύποι σφαλμάτων
    const ERROR_DB_CONNECTION = 1;
    const ERROR_DB_QUERY = 2;
    const ERROR_VALIDATION = 3;
    const ERROR_SYSTEM = 4;
    
    private $environment;
    
    public function __construct($environment) {
        $this->environment = $environment;
    }
    
    public function handleException($e) {
        // Καταγραφή του σφάλματος
        $this->logError($e);
        
        // Αποφασίστε τι μήνυμα θα εμφανιστεί στον χρήστη
        if ($e instanceof PDOException) {
            return $this->handleDatabaseException($e);
        } elseif ($e instanceof ValidationException) {
            return $e->getMessage();
        } else {
            return $this->createUserMessage(self::ERROR_SYSTEM);
        }
    }
    
    private function handleDatabaseException($e) {
        $error_code = $e->getCode();
        
        // Έλεγχος για συγκεκριμένους κωδικούς σφαλμάτων
        if (strpos($e->getMessage(), 'SQLSTATE[HY000]') !== false) {
            return $this->createUserMessage(self::ERROR_DB_CONNECTION);
        } elseif ($error_code == 23000) {
            // Παραβίαση μοναδικού περιορισμού
            if (strpos($e->getMessage(), 'Duplicate entry') !== false) {
                return "Τα στοιχεία που εισαγάγατε χρησιμοποιούνται ήδη.";
            }
        }
        
        return $this->createUserMessage(self::ERROR_DB_QUERY);
    }
    
    private function createUserMessage($errorType) {
        switch ($errorType) {
            case self::ERROR_DB_CONNECTION:
                return "Δεν είναι δυνατή η σύνδεση στη βάση δεδομένων αυτή τη στιγμή. Παρακαλώ δοκιμάστε αργότερα.";
            
            case self::ERROR_DB_QUERY:
                return "Παρουσιάστηκε πρόβλημα κατά την επεξεργασία του αιτήματός σας. Παρακαλώ δοκιμάστε αργότερα.";
            
            case self::ERROR_VALIDATION:
                return "Τα δεδομένα που υποβάλατε δεν είναι έγκυρα. Παρακαλώ ελέγξτε τις πληροφορίες σας και δοκιμάστε ξανά.";
            
            case self::ERROR_SYSTEM:
            default:
                return "Παρουσιάστηκε ένα απροσδόκητο σφάλμα. Οι διαχειριστές έχουν ενημερωθεί και εργάζονται για την επίλυσή του.";
        }
    }
    
    private function logError($e) {
        $message = sprintf(
            "[%s] %s: %s in %s on line %d\nStack trace: %s",
            date('Y-m-d H:i:s'),
            get_class($e),
            $e->getMessage(),
            $e->getFile(),
            $e->getLine(),
            $e->getTraceAsString()
        );
        
        error_log($message);
        
        // Σε περιβάλλον παραγωγής, μπορείτε να στείλετε ειδοποίηση για κρίσιμα σφάλματα
        if ($this->environment === 'production' && ($e instanceof PDOException || $e instanceof SystemException)) {
            // mail('admin@example.com', 'Κρίσιμο σφάλμα στην εφαρμογή', $message);
        }
    }
}

// Εξειδικευμένη κλάση εξαιρέσεων για σφάλματα επικύρωσης
class ValidationException extends Exception {}

// Εξειδικευμένη κλάση εξαιρέσεων για συστημικά σφάλματα
class SystemException extends Exception {}
?&gt;</code></pre>
    
    <pre><code>&lt;?php
// database.php - Κλάση διαχείρισης βάσης δεδομένων

require_once 'config.php';
require_once 'ErrorHandler.php';

class Database {
    private $conn;
    private $errorHandler;
    
    public function __construct($errorHandler) {
        $this->errorHandler = $errorHandler;
        $this->connect();
    }
    
    private function connect() {
        try {
            $this->conn = new PDO("mysql:host=" . DB_HOST . ";dbname=" . DB_NAME, DB_USER, DB_PASS);
            $this->conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        } catch (PDOException $e) {
            throw $e; // Αφήστε τον χειριστή σφαλμάτων να το διαχειριστεί
        }
    }
    
    public function query($sql, $params = []) {
        try {
            $stmt = $this->conn->prepare($sql);
            $stmt->execute($params);
            return $stmt;
        } catch (PDOException $e) {
            throw $e; // Αφήστε τον χειριστή σφαλμάτων να το διαχειριστεί
        }
    }
    
    public function select($sql, $params = []) {
        $stmt = $this->query($sql, $params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    public function insert($sql, $params = []) {
        $this->query($sql, $params);
        return $this->conn->lastInsertId();
    }
    
    public function update($sql, $params = []) {
        $stmt = $this->query($sql, $params);
        return $stmt->rowCount();
    }
    
    public function delete($sql, $params = []) {
        $stmt = $this->query($sql, $params);
        return $stmt->rowCount();
    }
    
    public function beginTransaction() {
        return $this->conn->beginTransaction();
    }
    
    public function commit() {
        return $this->conn->commit();
    }
    
    public function rollBack() {
        if ($this->conn->inTransaction()) {
            return $this->conn->rollBack();
        }
        return false;
    }
}
?&gt;</code></pre>
    
    <pre><code>&lt;?php
// example_usage.php - Παράδειγμα χρήσης των κλάσεων

require_once 'config.php';
require_once 'ErrorHandler.php';
require_once 'database.php';

// Δημιουργία χειριστή σφαλμάτων
$errorHandler = new ErrorHandler($environment);

try {
    // Δημιουργία σύνδεσης στη βάση
    $db = new Database($errorHandler);
    
    // Παράδειγμα εκτέλεσης επερωτήματος σε συναλλαγή
    $db->beginTransaction();
    
    // Δημιουργία παραγγελίας
    $orderId = $db->insert(
        "INSERT INTO orders (user_id, total_amount, order_date) VALUES (?, ?, NOW())",
        [1, 149.99]
    );
    
    // Προσθήκη στοιχείων παραγγελίας
    $db->insert(
        "INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)",
        [$orderId, 101, 2, 49.99]
    );
    
    $db->insert(
        "INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)",
        [$orderId, 102, 1, 50.01]
    );
    
    // Commit της συναλλαγής
    $db->commit();
    
    echo "Η παραγγελία με ID: " . $orderId . " καταχωρήθηκε επιτυχώς!";
    
} catch (Exception $e) {
    // Rollback σε περίπτωση σφάλματος
    if (isset($db)) {
        $db->rollBack();
    }
    
    // Χειρισμός του σφάλματος
    $errorMessage = $errorHandler->handleException($e);
    echo $errorMessage;
}
?&gt;</code></pre>
    
    <h3>Συμπέρασμα</h3>
    <p>Ο αποτελεσματικός χειρισμός σφαλμάτων είναι ουσιώδης για τη δημιουργία αξιόπιστων και ασφαλών εφαρμογών PHP-MySQL. Με τη χρήση των κατάλληλων τεχνικών χειρισμού σφαλμάτων, όπως οι εξαιρέσεις, η καταγραφή σφαλμάτων και οι συναλλαγές, μπορείτε να κάνετε την εφαρμογή σας πιο ανθεκτική σε προβλήματα και να βελτιώσετε την εμπειρία των χρηστών.</p>
    
    <p>Οι βασικές αρχές του καλού χειρισμού σφαλμάτων περιλαμβάνουν:</p>
    <ul>
        <li>Πρόληψη των σφαλμάτων όπου είναι δυνατό</li>
        <li>Χρήση try-catch για τον χειρισμό εξαιρέσεων</li>
        <li>Καταγραφή λεπτομερών πληροφοριών για τα σφάλματα</li>
        <li>Εμφάνιση φιλικών προς τον χρήστη μηνυμάτων</li>
        <li>Χρήση συναλλαγών για τη διατήρηση της ακεραιότητας των δεδομένων</li>
        <li>Προσαρμογή του χειρισμού σφαλμάτων ανάλογα με το περιβάλλον (ανάπτυξη ή παραγωγή)</li>
    </ul>
    
    <p>Με την εφαρμογή αυτών των πρακτικών, μπορείτε να δημιουργήσετε εφαρμογές που όχι μόνο λειτουργούν σωστά όταν όλα πάνε καλά, αλλά και αντιμετωπίζουν με χάρη και αποτελεσματικότητα τα αναπόφευκτα προβλήματα που μπορεί να προκύψουν.</p>
</section>
</script>
</body>
</html>