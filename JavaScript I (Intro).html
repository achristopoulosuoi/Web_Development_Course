<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Βασικές Αρχές JavaScript</title>
	<link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
	<a href="Index.html" class="back-to-index">← Επιστροφή στο Ευρετήριο</a>
        <h1>Βασικές Αρχές JavaScript</h1>
        
		<section id="introduction-to-javascript">
            <h2>1. Εισαγωγή στη JavaScript</h2>
            <p>Η JavaScript είναι μια γλώσσα προγραμματισμού υψηλού επιπέδου και διερμηνευμένη (interpreted), που αποτελεί μία από τις βασικές τεχνολογίες του διαδικτύου. Επιτρέπει τη δημιουργία δυναμικού και διαδραστικού περιεχομένου ιστοσελίδων, από απλά γραφικά εφέ και κινούμενα σχέδια μέχρι πολύπλοκες διαδικτυακές εφαρμογές.</p>
            
            <p>Σε αντίθεση με γλώσσες όπως η Java ή η C++, η JavaScript δεν χρειάζεται μεταγλώττιση (compilation) πριν την εκτέλεση. Ο κώδικας εκτελείται απευθείας από τον φυλλομετρητή (browser) του χρήστη καθώς διαβάζεται γραμμή προς γραμμή.</p>
            
            <div class="callout">
                <p><strong>Βασικά Σημεία:</strong></p>
                <ul>
                    <li>Η JavaScript εκτελείται στον φυλλομετρητή, από την πλευρά του πελάτη (client-side)</li>
                    <li>Με το Node.js, η JavaScript μπορεί επίσης να εκτελεστεί σε διακομιστές (servers)</li>
                    <li>Η JavaScript είναι δυναμικά τυποποιημένη (οι τύποι των μεταβλητών καθορίζονται κατά τη διάρκεια της εκτέλεσης)</li>
                    <li>Η JavaScript ακολουθεί ένα μοντέλο προγραμματισμού βασισμένο σε συμβάντα (event-driven programming)</li>
                </ul>
            </div>
        </section>

        <section id="variables-and-data-types">
            <h2>2. Μεταβλητές και Τύποι Δεδομένων</h2>
            
            <h3>Δήλωση Μεταβλητών</h3>
            <p>Η σύγχρονη JavaScript χρησιμοποιεί τις λέξεις-κλειδιά <code>let</code> και <code>const</code> για τη δήλωση μεταβλητών:</p>
            
            <p><strong>Τι είναι οι μεταβλητές;</strong> Οι μεταβλητές είναι "δοχεία" που αποθηκεύουν δεδομένα στη μνήμη του υπολογιστή. Κάθε μεταβλητή έχει ένα όνομα (αναγνωριστικό) που χρησιμοποιούμε για να αναφερθούμε στην τιμή που περιέχει.</p>
            
            <pre><code>// Χρήση του let για μεταβλητές που μπορούν να αλλάξουν τιμή αργότερα
let age = 25;
age = 26; // Αυτό είναι έγκυρο - μπορούμε να αλλάξουμε την τιμή

// Χρήση του const για μεταβλητές που δεν μπορούν να επαναπροσδιοριστούν
const PI = 3.14159;
// PI = 3; // Αυτό θα προκαλούσε σφάλμα - δεν μπορούμε να αλλάξουμε μια σταθερά</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><code>let</code>: Χρησιμοποιείται για μεταβλητές των οποίων η τιμή μπορεί να αλλάξει με την πάροδο του χρόνου. Για παράδειγμα, η ηλικία ενός χρήστη, ο αριθμός των προϊόντων στο καλάθι αγορών, κλπ.</li>
                <li><code>const</code>: Χρησιμοποιείται για μεταβλητές που δεν πρέπει να αλλάξουν μετά την αρχική τους εκχώρηση (σταθερές). Για παράδειγμα, η τιμή του π, ένα ID χρήστη, κλπ.</li>
            </ul>
            
            <div class="callout warning">
                <p><strong>Αποφύγετε τη χρήση του <code>var</code>:</strong> Αν και το <code>var</code> εξακολουθεί να υποστηρίζεται, έχει εμβέλεια συνάρτησης (function scope) αντί για εμβέλεια μπλοκ (block scope), γεγονός που μπορεί να οδηγήσει σε απρόσμενη συμπεριφορά. Στον σύγχρονο κώδικα προτιμήστε τα <code>let</code> και <code>const</code>.</p>
                
                <p><strong>Τι σημαίνει αυτό;</strong> Μεταβλητές που δηλώνονται με <code>var</code> μπορεί να είναι προσβάσιμες εκτός των μπλοκ κώδικα όπου δηλώθηκαν (π.χ. έξω από βρόχους ή δομές ελέγχου), ενώ οι μεταβλητές με <code>let</code> και <code>const</code> περιορίζονται στο μπλοκ όπου δηλώθηκαν, κάτι που βοηθά στην αποφυγή λαθών.</p>
            </div>
            
            <h3>Βασικοί Τύποι Δεδομένων</h3>
            <p>Η JavaScript έχει διάφορους τύπους δεδομένων που μπορείτε να χρησιμοποιήσετε για να αποθηκεύσετε διαφορετικά είδη πληροφοριών:</p>
            
            <table>
                <tr>
                    <th>Τύπος</th>
                    <th>Περιγραφή</th>
                    <th>Παράδειγμα</th>
                </tr>
                <tr>
                    <td>String</td>
                    <td>Κείμενο (αλφαριθμητικά δεδομένα)</td>
                    <td><code>'Γειά σου'</code></td>
                </tr>
                <tr>
                    <td>Number</td>
                    <td>Αριθμητικές τιμές (ακέραιοι και δεκαδικοί)</td>
                    <td><code>42</code> ή <code>3.14</code></td>
                </tr>
                <tr>
                    <td>Boolean</td>
                    <td>Λογικές τιμές (αληθές/ψευδές)</td>
                    <td><code>true</code> ή <code>false</code></td>
                </tr>
                <tr>
                    <td>Undefined</td>
                    <td>Μεταβλητή που έχει δηλωθεί αλλά δεν έχει εκχωρηθεί τιμή</td>
                    <td><code>let x;</code> // η x είναι undefined</td>
                </tr>
                <tr>
                    <td>Null</td>
                    <td>Σκόπιμη απουσία τιμής</td>
                    <td><code>let x = null;</code></td>
                </tr>
                <tr>
                    <td>Symbol</td>
                    <td>Μοναδικές και αμετάβλητες τιμές</td>
                    <td><code>Symbol('περιγραφή')</code></td>
                </tr>
                <tr>
                    <td>BigInt</td>
                    <td>Πολύ μεγάλοι ακέραιοι αριθμοί</td>
                    <td><code>9007199254740991n</code></td>
                </tr>
            </table>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>String:</strong> Χρησιμοποιείται για κείμενο. Μπορείτε να χρησιμοποιήσετε μονά ('') ή διπλά ("") εισαγωγικά.</li>
                <li><strong>Number:</strong> Η JavaScript δεν κάνει διάκριση μεταξύ ακέραιων και δεκαδικών αριθμών, όλοι είναι απλά τύπου Number.</li>
                <li><strong>Boolean:</strong> Χρησιμοποιείται για λογικές συνθήκες και έχει μόνο δύο τιμές: true (αληθές) ή false (ψευδές).</li>
                <li><strong>Undefined:</strong> Δηλώνει ότι μια μεταβλητή δεν έχει εκχωρηθεί ακόμα. Είναι διαφορετικό από το null.</li>
                <li><strong>Null:</strong> Αντιπροσωπεύει την σκόπιμη απουσία οποιασδήποτε τιμής ή αντικειμένου.</li>
            </ul>
            
            <h3>Σύνθετοι Τύποι Δεδομένων</h3>
            
            <h4>Αντικείμενα (Objects)</h4>
            <p>Τα αντικείμενα αποθηκεύουν συλλογές από ζεύγη κλειδιού-τιμής. Είναι ένας από τους πιο σημαντικούς τύπους δεδομένων στη JavaScript και χρησιμοποιούνται για την αποθήκευση σύνθετων δεδομένων:</p>
            
            <pre><code>const person = {
  name: 'Γιάννης',
  age: 30,
  isStudent: false,
  greet: function() {
    console.log('Γεια, το όνομά μου είναι ' + this.name);
  }
};</code></pre>
            
            <p><strong>Επεξήγηση:</strong> Στο παραπάνω παράδειγμα, δημιουργούμε ένα αντικείμενο <code>person</code> που περιέχει:</p>
            <ul>
                <li>Ιδιότητες (properties): name, age, isStudent - που αποθηκεύουν δεδομένα</li>
                <li>Μέθοδο (method): greet - που είναι μια συνάρτηση που ανήκει στο αντικείμενο</li>
            </ul>
            
            <p>Πρόσβαση στις ιδιότητες των αντικειμένων:</p>
            <pre><code>// Με τελεία (dot notation)
console.log(person.name); // 'Γιάννης'

// Με αγκύλες (bracket notation - χρήσιμο για δυναμικά κλειδιά)
const property = 'age';
console.log(person[property]); // 30

// Κλήση μεθόδων
person.greet(); // 'Γεια, το όνομά μου είναι Γιάννης'</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Η <strong>σημειογραφία τελείας</strong> (person.name) είναι η πιο συνηθισμένη μέθοδος πρόσβασης σε ιδιότητες.</li>
                <li>Η <strong>σημειογραφία αγκυλών</strong> (person[property]) είναι χρήσιμη όταν το όνομα της ιδιότητας είναι αποθηκευμένο σε μια μεταβλητή ή υπολογίζεται δυναμικά.</li>
                <li>Οι <strong>μέθοδοι</strong> είναι συναρτήσεις που ανήκουν σε ένα αντικείμενο και μπορούν να εκτελέσουν ενέργειες με τα δεδομένα του αντικειμένου.</li>
            </ul>
            
            <h4>Πίνακες (Arrays)</h4>
            <p>Οι πίνακες αποθηκεύουν διατεταγμένες συλλογές τιμών. Είναι ιδανικοί για την αποθήκευση λιστών δεδομένων:</p>
            
            <pre><code>const colors = ['κόκκινο', 'πράσινο', 'μπλε'];

// Πρόσβαση σε στοιχεία (με δείκτη που ξεκινά από το 0)
console.log(colors[0]); // 'κόκκινο'

// Προσθήκη στοιχείων
colors.push('κίτρινο'); // ['κόκκινο', 'πράσινο', 'μπλε', 'κίτρινο']

// Μήκος πίνακα
console.log(colors.length); // 4</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Οι πίνακες στη JavaScript χρησιμοποιούν <strong>δείκτες που ξεκινούν από το 0</strong>. Αυτό σημαίνει ότι το πρώτο στοιχείο έχει δείκτη 0, το δεύτερο δείκτη 1, κ.ο.κ.</li>
                <li>Η μέθοδος <strong>push()</strong> προσθέτει ένα νέο στοιχείο στο τέλος του πίνακα.</li>
                <li>Η ιδιότητα <strong>length</strong> μας δίνει τον αριθμό των στοιχείων στον πίνακα.</li>
            </ul>
            
            <div class="callout">
                <p><strong>Θυμηθείτε:</strong> Οι πίνακες στη JavaScript μπορούν να περιέχουν διαφορετικούς τύπους δεδομένων στον ίδιο πίνακα. Αυτό είναι διαφορετικό από πολλές άλλες γλώσσες προγραμματισμού όπου οι πίνακες πρέπει να περιέχουν στοιχεία του ίδιου τύπου:</p>
                <pre><code>const mixed = [42, 'μήλο', true, { name: 'Γιάννης' }, [1, 2, 3]];</code></pre>
                
                <p>Στο παραπάνω παράδειγμα, ο πίνακας <code>mixed</code> περιέχει:</p>
                <ul>
                    <li>Έναν αριθμό (42)</li>
                    <li>Ένα string ('μήλο')</li>
                    <li>Μια λογική τιμή (true)</li>
                    <li>Ένα αντικείμενο ({ name: 'Γιάννης' })</li>
                    <li>Έναν άλλο πίνακα ([1, 2, 3])</li>
                </ul>
                <p>Αυτή η ευελιξία κάνει τους πίνακες στη JavaScript πολύ ισχυρούς, αλλά είναι καλή πρακτική να διατηρείτε ομοιογένεια στους πίνακες για καλύτερη αναγνωσιμότητα και λιγότερα λάθη.</p>
            </div>
        </section>
        <section id="operators-and-expressions">
            <h2>3. Τελεστές και Εκφράσεις</h2>
            
            <h3>Αριθμητικοί Τελεστές</h3>
            <p>Οι αριθμητικοί τελεστές χρησιμοποιούνται για την εκτέλεση μαθηματικών πράξεων με αριθμητικές τιμές:</p>
            <pre><code>// Βασικές αριθμητικές πράξεις
let sum = 5 + 3;         // 8 (πρόσθεση)
let difference = 10 - 4; // 6 (αφαίρεση)
let product = 7 * 6;     // 42 (πολλαπλασιασμός)
let quotient = 20 / 4;   // 5 (διαίρεση)
let remainder = 10 % 3;  // 1 (υπόλοιπο διαίρεσης ή modulus)
let power = 2 ** 3;      // 8 (ύψωση σε δύναμη, το 2 υψωμένο στην 3η δύναμη)

// Αύξηση και μείωση κατά μία μονάδα
let count = 5;
count++;  // Η τιμή του count γίνεται 6 (αύξηση μετά την αξιολόγηση)
count--;  // Η τιμή του count γίνεται 5 ξανά (μείωση μετά την αξιολόγηση)</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Οι τελεστές <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> λειτουργούν όπως στα μαθηματικά.</li>
                <li>Ο τελεστής <code>%</code> (modulo) επιστρέφει το υπόλοιπο της διαίρεσης (π.χ. 10 % 3 = 1 γιατί το 10 διαιρείται με το 3 τρεις φορές και περισσεύει 1).</li>
                <li>Ο τελεστής <code>**</code> χρησιμοποιείται για την ύψωση σε δύναμη (εκθέτες).</li>
                <li>Οι τελεστές <code>++</code> και <code>--</code> αυξάνουν ή μειώνουν μια τιμή κατά 1 αντίστοιχα. Μπορούν να χρησιμοποιηθούν πριν ή μετά τη μεταβλητή, με διαφορετικά αποτελέσματα:
                    <ul>
                        <li><code>count++</code>: Πρώτα χρησιμοποιείται η τιμή και μετά αυξάνεται</li>
                        <li><code>++count</code>: Πρώτα αυξάνεται η τιμή και μετά χρησιμοποιείται</li>
                    </ul>
                </li>
            </ul>
            
            <h3>Τελεστές Σύγκρισης</h3>
            <p>Οι τελεστές σύγκρισης χρησιμοποιούνται για να συγκρίνουν δύο τιμές και να επιστρέψουν μια λογική τιμή (true/false):</p>
            <pre><code>// Τελεστές ισότητας
console.log(5 == '5');   // true (χαλαρή ισότητα, μετατρέπει τους τύπους)
console.log(5 === '5');  // false (αυστηρή ισότητα, ελέγχει τύπο και τιμή)
console.log(5 != '5');   // false (χαλαρή ανισότητα)
console.log(5 !== '5');  // true (αυστηρή ανισότητα)

// Τελεστές συσχέτισης
console.log(10 > 5);     // true (μεγαλύτερο από)
console.log(5 < 10);     // true (μικρότερο από)
console.log(10 >= 10);   // true (μεγαλύτερο ή ίσο με)
console.log(5 <= 10);    // true (μικρότερο ή ίσο με)</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><code>==</code> και <code>!=</code>: Ελέγχουν μόνο την ισότητα τιμών, επιτρέποντας μετατροπές τύπων. Για παράδειγμα, ο αριθμός 5 και το string '5' θεωρούνται ίσα.</li>
                <li><code>===</code> και <code>!==</code>: Ελέγχουν τόσο την ισότητα τιμών όσο και την ισότητα τύπων. Για παράδειγμα, ο αριθμός 5 και το string '5' ΔΕΝ θεωρούνται ίσα.</li>
                <li>Οι τελεστές <code>></code>, <code><</code>, <code>>=</code> και <code><=</code> λειτουργούν όπως στα μαθηματικά, συγκρίνοντας αριθμητικές τιμές.</li>
            </ul>
            
            <div class="callout warning">
                <p><strong>Βέλτιστη Πρακτική:</strong> Πάντα να χρησιμοποιείτε τελεστές αυστηρής ισότητας (<code>===</code> και <code>!==</code>) για να αποφύγετε απροσδόκητα προβλήματα μετατροπής τύπων.</p>
                
                <p><strong>Παράδειγμα προβλήματος με χαλαρή ισότητα:</strong></p>
                <pre><code>if (0 == '') {
    // Αυτός ο κώδικας ΘΑ εκτελεστεί επειδή το 0 και το '' μετατρέπονται στον ίδιο τύπο
}

if (0 === '') {
    // Αυτός ο κώδικας ΔΕΝ θα εκτελεστεί επειδή το 0 είναι αριθμός και το '' είναι string
}</code></pre>
            </div>
            
            <h3>Λογικοί Τελεστές</h3>
            <p>Οι λογικοί τελεστές χρησιμοποιούνται για τον συνδυασμό ή την αντιστροφή λογικών συνθηκών:</p>
            <pre><code>// Λογικό ΚΑΙ (AND)
console.log(true && true);   // true (και οι δύο συνθήκες είναι αληθείς)
console.log(true && false);  // false (μία συνθήκη είναι ψευδής)

// Λογικό Ή (OR)
console.log(true || false);  // true (τουλάχιστον μία συνθήκη είναι αληθής)
console.log(false || false); // false (καμία συνθήκη δεν είναι αληθής)

// Λογική ΑΡΝΗΣΗ (NOT)
console.log(!true);          // false (αντιστρέφει την τιμή)
console.log(!false);         // true (αντιστρέφει την τιμή)

// Πρακτικό παράδειγμα
const isAdult = age >= 18;
const hasPermission = userRole === 'admin';
const canAccess = isAdult && hasPermission;</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><code>&&</code> (Λογικό ΚΑΙ): Επιστρέφει <code>true</code> μόνο εάν και οι δύο συνθήκες είναι αληθείς.</li>
                <li><code>||</code> (Λογικό Ή): Επιστρέφει <code>true</code> εάν τουλάχιστον μία από τις συνθήκες είναι αληθής.</li>
                <li><code>!</code> (Λογική ΑΡΝΗΣΗ): Αντιστρέφει τη λογική τιμή (από <code>true</code> σε <code>false</code> και αντίστροφα).</li>
                <li>Στο πρακτικό παράδειγμα, ο χρήστης μπορεί να έχει πρόσβαση (<code>canAccess</code>) μόνο εάν είναι ενήλικας ΚΑΙ έχει δικαιώματα διαχειριστή.</li>
            </ul>
        </section>

        <section id="control-structures">
            <h2>4. Δομές Ελέγχου</h2>
            
            <h3>Δηλώσεις Συνθήκης</h3>
            <p>Οι δομές συνθήκης σας επιτρέπουν να εκτελείτε διαφορετικό κώδικα ανάλογα με το αν μια συνθήκη αξιολογείται ως αληθής ή ψευδής.</p>
            
            <h4>Δηλώσεις if-else</h4>
            <pre><code>const hour = new Date().getHours();

if (hour < 12) {
  console.log('Καλημέρα!');
} else if (hour < 18) {
  console.log('Καλό απόγευμα!');
} else {
  console.log('Καλό βράδυ!');
}</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Το παραπάνω παράδειγμα ελέγχει την τρέχουσα ώρα και εμφανίζει διαφορετικό χαιρετισμό ανάλογα με την ώρα.</li>
                <li>Η δήλωση <code>if</code> ελέγχει πρώτα αν είναι πριν τις 12 (<code>hour < 12</code>).</li>
                <li>Αν η πρώτη συνθήκη είναι ψευδής, ελέγχει αν είναι πριν τις 18 (<code>hour < 18</code>).</li>
                <li>Αν καμία από τις παραπάνω συνθήκες δεν είναι αληθής, εκτελείται το μπλοκ <code>else</code>.</li>
            </ul>
            
            <h4>Τριαδικός Τελεστής</h4>
            <p>Μια συντομογραφία για απλές συνθήκες που μοιάζει με ερώτηση και απάντηση:</p>
            <pre><code>const age = 20;
const status = age >= 18 ? 'Ενήλικας' : 'Ανήλικος';
console.log(status); // 'Ενήλικας'</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <p>Ο τριαδικός τελεστής (<code>? :</code>) είναι μια συντομογραφία για την εντολή if-else και λειτουργεί ως εξής:</p>
            <ul>
                <li><code>συνθήκη ? τιμή_αν_αληθής : τιμή_αν_ψευδής</code></li>
                <li>Στο παράδειγμα, αν η <code>age >= 18</code> είναι αληθής, η μεταβλητή <code>status</code> παίρνει την τιμή 'Ενήλικας', διαφορετικά παίρνει την τιμή 'Ανήλικος'.</li>
                <li>Είναι χρήσιμο για σύντομες και απλές συνθήκες, αλλά μπορεί να γίνει δυσανάγνωστο αν χρησιμοποιηθεί με πολύπλοκες συνθήκες.</li>
            </ul>
            
            <h4>Δήλωση switch</h4>
            <p>Η δήλωση switch είναι ένας εναλλακτικός τρόπος για να γράψετε πολλαπλές συνθήκες if-else, ειδικά όταν συγκρίνετε μια μεταβλητή με πολλές διαφορετικές τιμές:</p>
            <pre><code>const day = new Date().getDay();
let dayName;

switch (day) {
  case 0:
    dayName = 'Κυριακή';
    break;
  case 1:
    dayName = 'Δευτέρα';
    break;
  case 2:
    dayName = 'Τρίτη';
    break;
  case 3:
    dayName = 'Τετάρτη';
    break;
  case 4:
    dayName = 'Πέμπτη';
    break;
  case 5:
    dayName = 'Παρασκευή';
    break;
  case 6:
    dayName = 'Σάββατο';
    break;
  default:
    dayName = 'Άγνωστη ημέρα';
}

console.log(dayName);</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Η δήλωση <code>switch</code> εξετάζει μια μεταβλητή (εδώ την <code>day</code>) και την συγκρίνει με διάφορες περιπτώσεις (cases).</li>
                <li>Κάθε <code>case</code> αντιπροσωπεύει μια πιθανή τιμή της μεταβλητής.</li>
                <li>Η εντολή <code>break</code> είναι απαραίτητη στο τέλος κάθε περίπτωσης για να αποφευχθεί η "διαρροή" στις επόμενες περιπτώσεις.</li>
                <li>Η περίπτωση <code>default</code> εκτελείται αν καμία από τις άλλες περιπτώσεις δεν ταιριάζει (όπως το τελικό <code>else</code>).</li>
                <li>Στο παράδειγμα, η μέθοδος <code>getDay()</code> επιστρέφει έναν αριθμό από 0 (Κυριακή) έως 6 (Σάββατο).</li>
            </ul>
            
            <h3>Βρόχοι (Loops)</h3>
            <p>Οι βρόχοι επιτρέπουν την επαναλαμβανόμενη εκτέλεση ενός μπλοκ κώδικα για όσο διάστημα μια συγκεκριμένη συνθήκη είναι αληθής.</p>
            
            <h4>Βρόχος for</h4>
            <pre><code>// Βασικός βρόχος for
for (let i = 0; i < 5; i++) {
  console.log(i); // Εμφανίζει 0, 1, 2, 3, 4
}

// Διατρέχοντας έναν πίνακα
const fruits = ['μήλο', 'μπανάνα', 'πορτοκάλι'];
for (let i = 0; i < fruits.length; i++) {
  console.log(fruits[i]);
}</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <p>Ο βρόχος <code>for</code> έχει τρία μέρη:</p>
            <ol>
                <li><strong>Αρχικοποίηση</strong>: <code>let i = 0</code> - Εκτελείται μία φορά πριν από τον πρώτο κύκλο.</li>
                <li><strong>Συνθήκη</strong>: <code>i < 5</code> - Ελέγχεται πριν από κάθε κύκλο. Αν είναι ψευδής, ο βρόχος τερματίζεται.</li>
                <li><strong>Ενημέρωση</strong>: <code>i++</code> - Εκτελείται στο τέλος κάθε κύκλου.</li>
            </ol>
            <p>Το σώμα του βρόχου εκτελείται επανειλημμένα μέχρι η συνθήκη να γίνει ψευδής.</p>
            
            <h4>Βρόχος for...of</h4>
            <p>Ένας σύγχρονος τρόπος για να διατρέξετε επαναλαμβανόμενα αντικείμενα όπως πίνακες:</p>
            <pre><code>const fruits = ['μήλο', 'μπανάνα', 'πορτοκάλι'];
for (const fruit of fruits) {
  console.log(fruit);
}</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Ο βρόχος <code>for...of</code> είναι πιο απλός και ευανάγνωστος από τον παραδοσιακό βρόχο <code>for</code> όταν διατρέχετε στοιχεία ενός πίνακα.</li>
                <li>Σε κάθε επανάληψη, η μεταβλητή <code>fruit</code> παίρνει την τιμή του τρέχοντος στοιχείου του πίνακα.</li>
                <li>Δεν χρειάζεται να ανησυχείτε για δείκτες ή για το μήκος του πίνακα.</li>
                <li>Προτιμάται για απλή επανάληψη στοιχείων, αλλά δεν έχετε πρόσβαση στους δείκτες των στοιχείων.</li>
            </ul>
            
            <h4>Βρόχος for...in</h4>
            <p>Χρησιμοποιείται για την επανάληψη ιδιοτήτων αντικειμένων:</p>
            <pre><code>const person = {
  name: 'Γιάννης',
  age: 30,
  job: 'προγραμματιστής'
};

for (const key in person) {
  console.log(`${key}: ${person[key]}`);
}</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Ο βρόχος <code>for...in</code> διατρέχει τα ονόματα των ιδιοτήτων (κλειδιά) ενός αντικειμένου.</li>
                <li>Σε κάθε επανάληψη, η μεταβλητή <code>key</code> περιέχει το όνομα της τρέχουσας ιδιότητας.</li>
                <li>Για να αποκτήσετε πρόσβαση στην τιμή της ιδιότητας, χρησιμοποιείτε τη σημειογραφία αγκυλών: <code>person[key]</code>.</li>
                <li>Η έξοδος του παραπάνω κώδικα θα είναι:
                    <pre>name: Γιάννης
age: 30
job: προγραμματιστής</pre>
                </li>
                <li><strong>Σημείωση:</strong> Ο βρόχος <code>for...in</code> δεν συνιστάται για πίνακες, καθώς μπορεί να επιστρέψει επιπλέον ιδιότητες που δεν είναι αριθμητικοί δείκτες.</li>
            </ul>
            
            <h4>Βρόχος while</h4>
            <pre><code>let count = 0;

while (count < 5) {
  console.log(count);
  count++;
}</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Ο βρόχος <code>while</code> εκτελεί ένα μπλοκ κώδικα όσο η καθορισμένη συνθήκη είναι αληθής.</li>
                <li>Η συνθήκη ελέγχεται <strong>πριν</strong> από κάθε επανάληψη.</li>
                <li>Είναι χρήσιμος όταν δεν γνωρίζετε εκ των προτέρων πόσες φορές θα χρειαστεί να επαναληφθεί ο κώδικας.</li>
                <li>Πρέπει να διασφαλίσετε ότι κάποια στιγμή η συνθήκη θα γίνει ψευδής, διαφορετικά θα δημιουργηθεί ένας ατέρμονος βρόχος.</li>
            </ul>
            
            <h4>Βρόχος do...while</h4>
            <pre><code>let count = 0;

do {
  console.log(count);
  count++;
} while (count < 5);</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Ο βρόχος <code>do...while</code> είναι παρόμοιος με τον βρόχο <code>while</code>, αλλά με μία σημαντική διαφορά.</li>
                <li>Η συνθήκη ελέγχεται <strong>μετά</strong> την εκτέλεση του μπλοκ κώδικα.</li>
                <li>Αυτό σημαίνει ότι το μπλοκ κώδικα θα εκτελεστεί τουλάχιστον μία φορά, ακόμα κι αν η συνθήκη είναι αρχικά ψευδής.</li>
            </ul>
            
            <div class="callout">
                <p><strong>Βασική Διαφορά:</strong> Ένας βρόχος <code>do...while</code> θα εκτελεστεί πάντα τουλάχιστον μία φορά, ακόμα κι αν η συνθήκη είναι αρχικά ψευδής.</p>
                
                <p><strong>Παράδειγμα:</strong></p>
                <pre><code>// Με βρόχο while
let x = 10;
while (x < 10) {
  console.log(x); // Δεν θα εκτελεστεί καθόλου γιατί η συνθήκη είναι ήδη ψευδής
  x++;
}

// Με βρόχο do...while
let y = 10;
do {
  console.log(y); // Θα εκτελεστεί μία φορά παρόλο που η συνθήκη είναι ήδη ψευδής
  y++;
} while (y < 10);</code></pre>
            </div>
        </section>

        <section id="functions">
            <h2>5. Συναρτήσεις</h2>
            <p>Οι συναρτήσεις είναι επαναχρησιμοποιήσιμα μπλοκ κώδικα που εκτελούν συγκεκριμένες εργασίες. Επιτρέπουν την οργάνωση του κώδικα σε λογικές ενότητες, βελτιώνοντας την αναγνωσιμότητα και τη συντήρησή του.</p>
            
            <h3>Δηλώσεις Συναρτήσεων</h3>
            <pre><code>// Βασική δήλωση συνάρτησης
function greet(name) {
  return `Γεια σου, ${name}!`;
}
console.log(greet('Μαρία')); // 'Γεια σου, Μαρία!'</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Μια δήλωση συνάρτησης ξεκινά με τη λέξη-κλειδί <code>function</code>, ακολουθούμενη από το όνομα της συνάρτησης.</li>
                <li>Οι παράμετροι (π.χ., <code>name</code>) τοποθετούνται μέσα σε παρενθέσεις και λειτουργούν ως μεταβλητές μέσα στη συνάρτηση.</li>
                <li>Ο κώδικας που θα εκτελεστεί περικλείεται σε άγκιστρα <code>{ }</code>.</li>
                <li>Η εντολή <code>return</code> καθορίζει την τιμή που θα επιστρέψει η συνάρτηση. Χωρίς αυτήν, η συνάρτηση επιστρέφει <code>undefined</code>.</li>
                <li>Η συνάρτηση καλείται (εκτελείται) γράφοντας το όνομά της ακολουθούμενο από παρενθέσεις, περνώντας τυχόν απαιτούμενες τιμές (επιχειρήματα).</li>
            </ul>
            
            <h3>Εκφράσεις Συναρτήσεων</h3>
            <pre><code>// Ανώνυμη έκφραση συνάρτησης
const greet = function(name) {
  return `Γεια σου, ${name}!`;
};
console.log(greet('Γιώργος')); // 'Γεια σου, Γιώργος!'</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Μια έκφραση συνάρτησης δημιουργεί μια συνάρτηση και την αποθηκεύει σε μια μεταβλητή.</li>
                <li>Η συνάρτηση είναι ανώνυμη (δεν έχει όνομα μετά τη λέξη <code>function</code>).</li>
                <li>Η μεταβλητή <code>greet</code> χρησιμοποιείται τώρα για να αναφερθούμε και να καλέσουμε τη συνάρτηση.</li>
                <li><strong>Διαφορά από τις δηλώσεις συναρτήσεων:</strong> Οι εκφράσεις συναρτήσεων ορίζονται κατά την εκτέλεση του προγράμματος, ενώ οι δηλώσεις συναρτήσεων "ανυψώνονται" (hoisted) στην κορυφή του πεδίου εμβέλειας. Αυτό σημαίνει ότι μπορείτε να καλέσετε μια δηλωμένη συνάρτηση πριν από τον ορισμό της, αλλά όχι μια έκφραση συνάρτησης.</li>
            </ul>
            
            <h3>Συναρτήσεις Βέλους (Arrow Functions)</h3>
            <p>Μια σύγχρονη, συνοπτική σύνταξη που εισήχθη στην ES6:</p>
            <pre><code>// Συνάρτηση βέλους με ρητή επιστροφή
const greet = (name) => {
  return `Γεια σου, ${name}!`;
};
// Συντομότερη σύνταξη για συναρτήσεις μίας έκφρασης
const greetShort = name => `Γεια σου, ${name}!`;
console.log(greetShort('Ελένη')); // 'Γεια σου, Ελένη!'</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Οι συναρτήσεις βέλους χρησιμοποιούν τον τελεστή <code>=></code> αντί για τη λέξη-κλειδί <code>function</code>.</li>
                <li>Αν υπάρχει μόνο μία παράμετρος, οι παρενθέσεις είναι προαιρετικές: <code>name => { ... }</code></li>
                <li>Αν η συνάρτηση έχει μόνο μία έκφραση που επιστρέφει τιμή, τα άγκιστρα και η λέξη <code>return</code> μπορούν να παραληφθούν: <code>name => `Γεια σου, ${name}!`</code></li>
                <li>Οι συναρτήσεις βέλους είναι ιδανικές για σύντομες, απλές λειτουργίες, ειδικά ως συναρτήσεις επανάκλησης (callbacks).</li>
            </ul>
            
            <div class="callout">
                <p><strong>Σημείωση:</strong> Οι συναρτήσεις βέλους δεν έχουν δικό τους πλαίσιο <code>this</code>, το κληρονομούν από το περιβάλλον πεδίο εμβέλειας.</p>
                
                <p><strong>Τι σημαίνει αυτό;</strong> Σε παραδοσιακές συναρτήσεις, η λέξη-κλειδί <code>this</code> αναφέρεται στο αντικείμενο που κάλεσε τη συνάρτηση. Στις συναρτήσεις βέλους, το <code>this</code> διατηρεί την τιμή από το περιβάλλον context. Αυτό μπορεί να είναι πολύ χρήσιμο αλλά και πηγή σύγχυσης αν δεν το γνωρίζετε. Για παράδειγμα:</p>
                
                <pre><code>// Με κανονική συνάρτηση
const person1 = {
  name: 'Γιάννης',
  greet: function() {
    console.log(`Γεια, είμαι ο ${this.name}`); // 'Γεια, είμαι ο Γιάννης'
  }
};

// Με συνάρτηση βέλους
const person2 = {
  name: 'Μαρία',
  greet: () => {
    console.log(`Γεια, είμαι η ${this.name}`); // 'Γεια, είμαι η undefined'
  }
};</code></pre>
            </div>
            
            <h3>Παράμετροι και Επιχειρήματα</h3>
            
            <h4>Προεπιλεγμένες Παράμετροι</h4>
            <pre><code>function greet(name = 'Επισκέπτης') {
  return `Γεια σου, ${name}!`;
}
console.log(greet()); // 'Γεια σου, Επισκέπτης!'
console.log(greet('Δημήτρης')); // 'Γεια σου, Δημήτρης!'</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Οι προεπιλεγμένες παράμετροι επιτρέπουν τον ορισμό τιμών που θα χρησιμοποιηθούν αν δεν παρέχονται επιχειρήματα κατά την κλήση της συνάρτησης.</li>
                <li>Στο παράδειγμα, αν η συνάρτηση <code>greet()</code> κληθεί χωρίς παραμέτρους, η παράμετρος <code>name</code> θα πάρει την τιμή 'Επισκέπτης'.</li>
                <li>Αυτό είναι χρήσιμο για τη δημιουργία συναρτήσεων που λειτουργούν ακόμα κι αν λείπουν ορισμένες παράμετροι.</li>
            </ul>
            
            <h4>Παράμετροι Υπολοίπου (Rest Parameters)</h4>
            <pre><code>function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}
console.log(sum(1, 2, 3, 4)); // 10</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Οι παράμετροι υπολοίπου (με τη σύνταξη <code>...paramName</code>) επιτρέπουν τη συλλογή απεριόριστου αριθμού επιχειρημάτων σε έναν πίνακα.</li>
                <li>Στο παράδειγμα, η παράμετρος <code>...numbers</code> συλλέγει όλα τα επιχειρήματα και τα αποθηκεύει σε έναν πίνακα με όνομα <code>numbers</code>.</li>
                <li>Η μέθοδος <code>reduce()</code> στη συνέχεια χρησιμοποιείται για να προσθέσει όλους τους αριθμούς στον πίνακα.</li>
                <li>Αυτό είναι χρήσιμο όταν δεν γνωρίζετε εκ των προτέρων πόσα επιχειρήματα θα περάσουν στη συνάρτηση.</li>
            </ul>
            
            <h3>Εμβέλεια (Scope) και Closures</h3>
            
            <h4>Εμβέλεια Μεταβλητών</h4>
            <pre><code>// Καθολική εμβέλεια (Global scope)
const globalVar = 'Είμαι καθολική';
function exampleFunction() {
  // Εμβέλεια συνάρτησης (Function scope)
  const functionVar = 'Είμαι στην εμβέλεια της συνάρτησης';
  
  if (true) {
    // Εμβέλεια μπλοκ (Block scope)
    const blockVar = 'Είμαι στην εμβέλεια του μπλοκ';
    console.log(globalVar);     // Προσβάσιμη
    console.log(functionVar);   // Προσβάσιμη
    console.log(blockVar);      // Προσβάσιμη
  }
  
  console.log(globalVar);       // Προσβάσιμη
  console.log(functionVar);     // Προσβάσιμη
  // console.log(blockVar);     // Σφάλμα: η blockVar δεν έχει οριστεί
}
console.log(globalVar);         // Προσβάσιμη
// console.log(functionVar);    // Σφάλμα: η functionVar δεν έχει οριστεί</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>Καθολική εμβέλεια (Global scope):</strong> Μεταβλητές που ορίζονται έξω από οποιαδήποτε συνάρτηση ή μπλοκ. Είναι προσβάσιμες από οπουδήποτε στον κώδικα.</li>
                <li><strong>Εμβέλεια συνάρτησης (Function scope):</strong> Μεταβλητές που ορίζονται μέσα σε μια συνάρτηση. Είναι προσβάσιμες μόνο μέσα στη συνάρτηση.</li>
                <li><strong>Εμβέλεια μπλοκ (Block scope):</strong> Μεταβλητές που ορίζονται μέσα σε ένα μπλοκ κώδικα (π.χ., μέσα σε <code>if</code>, <code>for</code>, κλπ.). Είναι προσβάσιμες μόνο μέσα σε αυτό το μπλοκ.</li>
                <li>Οι μεταβλητές που ορίζονται με <code>let</code> και <code>const</code> έχουν εμβέλεια μπλοκ, ενώ οι μεταβλητές που ορίζονται με <code>var</code> έχουν εμβέλεια συνάρτησης.</li>
            </ul>
            
            <h4>Closures</h4>
            <p>Ένα closure είναι μια συνάρτηση που έχει πρόσβαση σε μεταβλητές από την εξωτερική της εμβέλεια, ακόμα και αφού η εξωτερική συνάρτηση έχει ολοκληρώσει την εκτέλεσή της:</p>
            <pre><code>function createCounter() {
  let count = 0;
  
  return function() {
    count++;
    return count;
  };
}
const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Στο παραπάνω παράδειγμα, η συνάρτηση <code>createCounter()</code> δημιουργεί μια μεταβλητή <code>count</code> και επιστρέφει μια εσωτερική συνάρτηση που έχει πρόσβαση σε αυτή τη μεταβλητή.</li>
                <li>Όταν η <code>createCounter()</code> ολοκληρώνεται, κανονικά η μεταβλητή <code>count</code> θα έπρεπε να καταστραφεί.</li>
                <li>Ωστόσο, επειδή η εσωτερική συνάρτηση εξακολουθεί να αναφέρεται στη μεταβλητή <code>count</code>, η JavaScript διατηρεί τη μεταβλητή στη μνήμη.</li>
                <li>Κάθε φορά που καλούμε τη συνάρτηση <code>counter()</code>, έχει πρόσβαση στην ίδια μεταβλητή <code>count</code>, επιτρέποντάς μας να διατηρήσουμε την κατάσταση μεταξύ κλήσεων.</li>
                <li>Τα closures είναι πολύ ισχυρά και χρησιμοποιούνται συχνά στη JavaScript για να δημιουργήσουν ιδιωτικές μεταβλητές και να διατηρήσουν την κατάσταση.</li>
            </ul>
            
            <div class="callout success">
                <p><strong>Πρακτική Εφαρμογή των Closures:</strong></p>
                <p>Τα closures είναι ιδιαίτερα χρήσιμα για:</p>
                <ul>
                    <li><strong>Ενθυλάκωση δεδομένων:</strong> Δημιουργία "ιδιωτικών" μεταβλητών που δεν είναι άμεσα προσβάσιμες εκτός της συνάρτησης.</li>
                    <li><strong>Αποθήκευση κατάστασης:</strong> Διατήρηση πληροφοριών μεταξύ των κλήσεων συναρτήσεων χωρίς τη χρήση καθολικών μεταβλητών.</li>
                    <li><strong>Δημιουργία συναρτήσεων υψηλότερης τάξης:</strong> Συναρτήσεις που δημιουργούν ή επιστρέφουν άλλες συναρτήσεις με προσαρμοσμένη συμπεριφορά.</li>
                </ul>
                <pre><code>// Παράδειγμα: Συνάρτηση που δημιουργεί προσαρμοσμένους πολλαπλασιαστές
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15</code></pre>
            </div>
        </section>

        <section id="working-with-objects">
            <h2>6. Εργασία με Αντικείμενα</h2>
            <p>Τα αντικείμενα αποτελούν έναν από τους θεμελιώδεις τύπους δεδομένων στη JavaScript και επιτρέπουν την οργάνωση των δεδομένων και της συμπεριφοράς σε μια λογική δομή.</p>
            
            <h3>Δημιουργία Αντικειμένων</h3>
            <pre><code>// Χρήση αντικειμενικού προτύπου (Object literal)
const person = {
  firstName: 'Γιάννης',
  lastName: 'Παπαδόπουλος',
  age: 30
};

// Χρήση του κατασκευαστή Object
const user = new Object();
user.name = 'Μαρία';
user.age = 25;</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>Αντικειμενικό πρότυπο (Object literal):</strong> Η πιο συνηθισμένη μέθοδος για τη δημιουργία αντικειμένων στη JavaScript. Χρησιμοποιεί άγκιστρα <code>{ }</code> και ορίζει ζεύγη κλειδιού-τιμής.</li>
                <li><strong>Κατασκευαστής Object:</strong> Μια εναλλακτική μέθοδος που χρησιμοποιεί τον ενσωματωμένο κατασκευαστή <code>Object</code>. Οι ιδιότητες προστίθενται μετά τη δημιουργία του αντικειμένου.</li>
                <li>Κάθε ιδιότητα αποτελείται από ένα όνομα (κλειδί) και μια τιμή, διαχωρισμένα με άνω-κάτω τελεία (<code>:</code>).</li>
            </ul>
            
            <h3>Μέθοδοι Αντικειμένων</h3>
            <pre><code>const person = {
  firstName: 'Γιάννης',
  lastName: 'Παπαδόπουλος',
  // Ορισμός μεθόδου με παραδοσιακή σύνταξη
  getFullName: function() {
    return `${this.firstName} ${this.lastName}`;
  },
  // Σύντομη σύνταξη μεθόδου (ES6)
  greet() {
    return `Γεια, είμαι ο ${this.getFullName()}`;
  }
};

console.log(person.getFullName()); // 'Γιάννης Παπαδόπουλος'
console.log(person.greet()); // 'Γεια, είμαι ο Γιάννης Παπαδόπουλος'</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>Μέθοδοι:</strong> Συναρτήσεις που ανήκουν σε ένα αντικείμενο.</li>
                <li>Υπάρχουν δύο τρόποι ορισμού μεθόδων:
                    <ul>
                        <li>Παραδοσιακή σύνταξη: <code>ονομαΜεθόδου: function() { ... }</code></li>
                        <li>Σύντομη σύνταξη (ES6): <code>ονομαΜεθόδου() { ... }</code></li>
                    </ul>
                </li>
                <li>Η λέξη-κλειδί <code>this</code> αναφέρεται στο τρέχον αντικείμενο και επιτρέπει την πρόσβαση στις ιδιότητές του.</li>
                <li>Οι μέθοδοι καλούνται χρησιμοποιώντας τη σημειογραφία τελείας: <code>αντικείμενο.μέθοδος()</code>.</li>
            </ul>
            
			<h3>Η Λέξη-Κλειδί "this"</h3>
<p>Η λέξη-κλειδί <code>this</code> είναι από τις πιο σημαντικές έννοιες στη JavaScript, αλλά μπορεί να προκαλέσει σύγχυση. Αναφέρεται στο "πλαίσιο" εκτέλεσης του κώδικα, και η τιμή της εξαρτάται από το πού και πώς καλείται μια συνάρτηση.</p>

<pre><code>// Βασική χρήση του this μέσα σε μέθοδο αντικειμένου
const person = {
  name: 'Μαρία',
  greet: function() {
    console.log(`Γεια, το όνομά μου είναι ${this.name}`);
  }
};

person.greet(); // "Γεια, το όνομά μου είναι Μαρία"

// Το this σε καθολικό περιβάλλον
console.log(this); // Αναφέρεται στο Window object (στο browser)</code></pre>

<p><strong>Επεξήγηση των βασικών κανόνων του this:</strong></p>
<ul>
  <li><strong>Σε μεθόδους αντικειμένων:</strong> Το <code>this</code> αναφέρεται στο αντικείμενο που "κατέχει" τη μέθοδο (το αντικείμενο πριν την τελεία).</li>
  <li><strong>Μόνο του ή σε συνάρτηση:</strong> Σε αυστηρή λειτουργία (<code>'use strict'</code>), το <code>this</code> είναι <code>undefined</code>. Σε μη-αυστηρή λειτουργία, αναφέρεται στο καθολικό αντικείμενο (συνήθως <code>window</code> στον browser).</li>
  <li><strong>Σε συναρτήσεις βέλους:</strong> Το <code>this</code> διατηρεί την τιμή από το περιβάλλον context που περικλείει τη συνάρτηση (δεν έχει δικό του <code>this</code>).</li>
  <li><strong>Με τις μεθόδους call(), apply(), bind():</strong> Μπορείτε να ορίσετε ρητά τι θα είναι το <code>this</code> σε μια συνάρτηση.</li>
</ul>

<div class="callout">
  <p><strong>Παράδειγμα διαφοράς μεταξύ κανονικών συναρτήσεων και συναρτήσεων βέλους:</strong></p>
  <pre><code>const user = {
  name: 'Γιώργος',
  // Κανονική συνάρτηση: το this αναφέρεται στο αντικείμενο user
  sayHello: function() {
    console.log(`Γεια από τον ${this.name}`);
  },
  // Συνάρτηση βέλους: το this ΔΕΝ αναφέρεται στο αντικείμενο user
  sayHelloArrow: () => {
    console.log(`Γεια από τον ${this.name}`); // this.name θα είναι undefined
  }
};

user.sayHello();      // "Γεια από τον Γιώργος"
user.sayHelloArrow(); // "Γεια από τον undefined"</code></pre>
</div>

<h4>Αλλαγή του this με call(), apply() και bind()</h4>
<pre><code>function greet() {
  console.log(`Γεια, το όνομά μου είναι ${this.name}`);
}

const person1 = { name: 'Νίκος' };
const person2 = { name: 'Ελένη' };

// Χρήση της call() για να καλέσουμε τη συνάρτηση με συγκεκριμένο this
greet.call(person1); // "Γεια, το όνομά μου είναι Νίκος"
greet.call(person2); // "Γεια, το όνομά μου είναι Ελένη"

// Η bind() δημιουργεί μια νέα συνάρτηση με σταθερό this
const greetNikos = greet.bind(person1);
greetNikos(); // "Γεια, το όνομά μου είναι Νίκος" (πάντα)</code></pre>

<p><strong>Επεξήγηση:</strong></p>
<ul>
  <li><strong>call(thisArg, arg1, arg2, ...):</strong> Καλεί τη συνάρτηση με το καθορισμένο <code>this</code> και μεμονωμένα επιχειρήματα.</li>
  <li><strong>apply(thisArg, [args]):</strong> Παρόμοιο με το <code>call()</code>, αλλά δέχεται τα επιχειρήματα ως πίνακα.</li>
  <li><strong>bind(thisArg, arg1, arg2, ...):</strong> Δημιουργεί μια νέα συνάρτηση με το καθορισμένο <code>this</code> και προ-καθορισμένα επιχειρήματα.</li>
</ul>

<div class="callout warning">
  <p><strong>Συχνά Λάθη με το this:</strong></p>
  <p>Ένα κοινό λάθος είναι να θεωρείτε ότι το <code>this</code> αναφέρεται πάντα στο αντικείμενο όπου ορίζεται μια συνάρτηση. Στην πραγματικότητα, εξαρτάται από το <em>πώς καλείται</em> η συνάρτηση, όχι από το πού ορίζεται.</p>
  <pre><code>const user = {
  name: 'Δημήτρης',
  greet: function() {
    console.log(`Γεια, είμαι ο ${this.name}`);
  }
};

user.greet(); // "Γεια, είμαι ο Δημήτρης" (καλείται ως μέθοδος)

const func = user.greet; // αποθήκευση της συνάρτησης σε μεταβλητή
func(); // "Γεια, είμαι ο undefined" (καλείται ως απλή συνάρτηση)</code></pre>
  <p>Στο παραπάνω παράδειγμα, όταν καλούμε τη συνάρτηση ως <code>user.greet()</code>, το <code>this</code> αναφέρεται στο <code>user</code>. Όταν την αποθηκεύουμε σε μεταβλητή και την καλούμε ως <code>func()</code>, το <code>this</code> δεν αναφέρεται πλέον στο <code>user</code>, αλλά στο καθολικό αντικείμενο ή είναι <code>undefined</code> σε αυστηρή λειτουργία.</p>
</div>
			
			
			
            <h3>Πρωτότυπα και Κληρονομικότητα</h3>
            <pre><code>// Συνάρτηση κατασκευαστή
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

// Προσθήκη μεθόδων στο πρωτότυπο
Person.prototype.getFullName = function() {
  return `${this.firstName} ${this.lastName}`;
};

// Δημιουργία αντικειμένων από τον κατασκευαστή
const person1 = new Person('Γιάννης', 'Παπαδόπουλος');
const person2 = new Person('Μαρία', 'Γεωργίου');

console.log(person1.getFullName()); // 'Γιάννης Παπαδόπουλος'
console.log(person2.getFullName()); // 'Μαρία Γεωργίου'</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>Συνάρτηση κατασκευαστή:</strong> Μια συνάρτηση που χρησιμοποιείται με τον τελεστή <code>new</code> για τη δημιουργία αντικειμένων. Παραδοσιακά, τα ονόματα των κατασκευαστών ξεκινούν με κεφαλαίο γράμμα.</li>
                <li><strong>Πρωτότυπο (Prototype):</strong> Ένα αντικείμενο από το οποίο άλλα αντικείμενα κληρονομούν ιδιότητες και μεθόδους.</li>
                <li><strong>Person.prototype:</strong> Το αντικείμενο πρωτότυπο που μοιράζονται όλα τα στιγμιότυπα του <code>Person</code>.</li>
                <li>Προσθέτοντας μεθόδους στο πρωτότυπο αντί στον κατασκευαστή, η μέθοδος ορίζεται μία φορά στη μνήμη και κοινοποιείται σε όλα τα στιγμιότυπα, βελτιώνοντας την αποδοτικότητα της μνήμης.</li>
            </ul>
            
            <div class="callout">
                <p><strong>Σημείωση:</strong> Το σύστημα πρωτοτύπων της JavaScript είναι διαφορετικό από τα παραδοσιακά συστήματα κλάσεων που μπορεί να έχετε συναντήσει σε άλλες γλώσσες. Στη JavaScript, η κληρονομικότητα επιτυγχάνεται μέσω μιας "αλυσίδας πρωτοτύπων" όπου τα αντικείμενα κληρονομούν ιδιότητες και μεθόδους από τα πρωτότυπά τους.</p>
            </div>
            
            <h3>Κλάσεις ES6</h3>
            <p>Σύγχρονη σύνταξη για αντικειμενοστρεφή προγραμματισμό στη JavaScript:</p>
            <pre><code>class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  }
  
  greet() {
    return `Γεια, είμαι ο/η ${this.getFullName()}`;
  }
}

class Employee extends Person {
  constructor(firstName, lastName, position) {
    super(firstName, lastName);
    this.position = position;
  }
  
  getDetails() {
    return `${this.getFullName()}, ${this.position}`;
  }
}

const employee = new Employee('Γιάννης', 'Παπαδόπουλος', 'Προγραμματιστής');
console.log(employee.getFullName()); // 'Γιάννης Παπαδόπουλος'
console.log(employee.getDetails()); // 'Γιάννης Παπαδόπουλος, Προγραμματιστής'</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>Κλάσεις:</strong> Εισήχθησαν στην ES6 ως "syntactic sugar" (χαρακτηριστικά στον προγραμματισμό που διευκολύνουν την ανάγνωση ή την εγγραφή του κώδικα) πάνω από το υπάρχον σύστημα πρωτοτύπων. Παρέχουν πιο οικεία σύνταξη για προγραμματιστές από άλλες γλώσσες.</li>
                <li><strong>constructor:</strong> Ειδική μέθοδος που καλείται κατά τη δημιουργία στιγμιοτύπων με τον τελεστή <code>new</code>. Χρησιμοποιείται για την αρχικοποίηση ιδιοτήτων.</li>
                <li><strong>extends:</strong> Δημιουργεί μια κλάση που είναι παιδί (κληρονομεί) μιας άλλης κλάσης.</li>
                <li><strong>super:</strong> Καλεί τον constructor της γονικής κλάσης. Απαιτείται όταν επεκτείνετε μια κλάση και ορίζετε δικό σας constructor.</li>
                <li>Οι μέθοδοι που ορίζονται μέσα σε μια κλάση προστίθενται αυτόματα στο πρωτότυπο της κλάσης, όχι στα μεμονωμένα στιγμιότυπα.</li>
            </ul>
            
            <div class="callout success">
                <p><strong>Σύγκριση Παλαιάς και Νέας Σύνταξης:</strong></p>
                <p>Η σύνταξη των κλάσεων ES6 και η παραδοσιακή σύνταξη πρωτοτύπων είναι ισοδύναμες κάτω από το καπό. Η επιλογή μεταξύ τους είναι θέμα προτίμησης και συμβατότητας.</p>
                <table>
                    <tr>
                        <th>Χαρακτηριστικό</th>
                        <th>Παραδοσιακή Σύνταξη</th>
                        <th>Σύνταξη ES6</th>
                    </tr>
                    <tr>
                        <td>Αναγνωσιμότητα</td>
                        <td>Λιγότερο διαισθητική</td>
                        <td>Πιο καθαρή και οικεία</td>
                    </tr>
                    <tr>
                        <td>Κληρονομικότητα</td>
                        <td>Πιο πολύπλοκη</td>
                        <td>Απλουστευμένη με το <code>extends</code></td>
                    </tr>
                    <tr>
                        <td>Λειτουργικότητα</td>
                        <td>Πλήρης</td>
                        <td>Πλήρης</td>
                    </tr>
                    <tr>
                        <td>Συμβατότητα</td>
                        <td>Όλα τα περιβάλλοντα</td>
                        <td>Νεότερα περιβάλλοντα ή με transpilers</td>
                    </tr>
                </table>
            </div>
        </section>

        <section id="arrays-and-methods">
            <h2>7. Πίνακες και Μέθοδοι Πινάκων</h2>
            <p>Οι πίνακες επιτρέπουν την αποθήκευση και διαχείριση συλλογών δεδομένων σε μια διατεταγμένη λίστα. Η JavaScript παρέχει πλούσιες μεθόδους για τον χειρισμό και τη διαχείριση των πινάκων.</p>
            
            <h3>Δημιουργία Πινάκων</h3>
            <pre><code>// Χρήση προτύπου πίνακα (Array literal)
const fruits = ['μήλο', 'μπανάνα', 'πορτοκάλι'];

// Χρήση του κατασκευαστή Array
const numbers = new Array(1, 2, 3, 4, 5);

// Δημιουργία κενού πίνακα συγκεκριμένου μήκους
const emptyArray = new Array(5); // Δημιουργεί πίνακα με 5 κενές θέσεις</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>Πρότυπο πίνακα (Array literal):</strong> Η πιο συνηθισμένη μέθοδος, χρησιμοποιώντας αγκύλες <code>[ ]</code> και διαχωρίζοντας τα στοιχεία με κόμματα.</li>
                <li><strong>Κατασκευαστής Array:</strong> Εναλλακτική μέθοδος χρησιμοποιώντας τον ενσωματωμένο κατασκευαστή <code>Array</code>.</li>
                <li><strong>Προσοχή:</strong> Ο κατασκευαστής <code>new Array(n)</code> με έναν αριθμό δημιουργεί έναν πίνακα με <code>n</code> κενές θέσεις, όχι έναν πίνακα με ένα στοιχείο.</li>
            </ul>
            
            <h3>Συνήθεις Μέθοδοι Πινάκων</h3>
            
            <h4>Προσθήκη και Αφαίρεση Στοιχείων</h4>
            <pre><code>const fruits = ['μήλο', 'μπανάνα'];

// Προσθήκη στο τέλος
fruits.push('πορτοκάλι');  // ['μήλο', 'μπανάνα', 'πορτοκάλι']

// Αφαίρεση από το τέλος
const lastFruit = fruits.pop();  // lastFruit = 'πορτοκάλι', fruits = ['μήλο', 'μπανάνα']

// Προσθήκη στην αρχή
fruits.unshift('μάνγκο');  // ['μάνγκο', 'μήλο', 'μπανάνα']

// Αφαίρεση από την αρχή
const firstFruit = fruits.shift();  // firstFruit = 'μάνγκο', fruits = ['μήλο', 'μπανάνα']</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>push():</strong> Προσθέτει ένα ή περισσότερα στοιχεία στο τέλος του πίνακα και επιστρέφει το νέο μήκος.</li>
                <li><strong>pop():</strong> Αφαιρεί και επιστρέφει το τελευταίο στοιχείο του πίνακα.</li>
                <li><strong>unshift():</strong> Προσθέτει ένα ή περισσότερα στοιχεία στην αρχή του πίνακα και επιστρέφει το νέο μήκος.</li>
                <li><strong>shift():</strong> Αφαιρεί και επιστρέφει το πρώτο στοιχείο του πίνακα.</li>
                <li><strong>Μνημονικό βοήθημα:</strong> Οι μέθοδοι <code>push()</code> και <code>pop()</code> λειτουργούν στο τέλος του πίνακα, ενώ οι <code>unshift()</code> και <code>shift()</code> λειτουργούν στην αρχή.</li>
            </ul>
            
            <h4>Εύρεση και Φιλτράρισμα</h4>
            <pre><code>const numbers = [1, 2, 3, 4, 5, 6];

// Έλεγχος αν υπάρχει στοιχείο
console.log(numbers.includes(3));  // true

// Εύρεση δείκτη στοιχείου
console.log(numbers.indexOf(4));  // 3 (δείκτης του 4)
console.log(numbers.indexOf(10)); // -1 (δεν βρέθηκε)

// Εύρεση πρώτου στοιχείου που ικανοποιεί μια συνθήκη
const firstEven = numbers.find(num => num % 2 === 0);
console.log(firstEven);  // 2

// Φιλτράρισμα πίνακα βάσει συνθήκης
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers);  // [2, 4, 6]</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>includes():</strong> Επιστρέφει <code>true</code> αν ο πίνακας περιέχει το συγκεκριμένο στοιχείο, αλλιώς <code>false</code>.</li>
                <li><strong>indexOf():</strong> Επιστρέφει τον πρώτο δείκτη στον οποίο βρίσκεται ένα στοιχείο, ή <code>-1</code> αν δεν βρεθεί.</li>
                <li><strong>find():</strong> Επιστρέφει το πρώτο στοιχείο που ικανοποιεί τη δοθείσα συνάρτηση ελέγχου. Στο παράδειγμα, επιστρέφει τον πρώτο ζυγό αριθμό.</li>
                <li><strong>filter():</strong> Δημιουργεί έναν νέο πίνακα με όλα τα στοιχεία που περνούν τον έλεγχο που παρέχεται από τη συνάρτηση. Στο παράδειγμα, επιστρέφει όλους τους ζυγούς αριθμούς.</li>
                <li>Οι συναρτήσεις <code>find()</code> και <code>filter()</code> δέχονται συναρτήσεις callback που εφαρμόζονται σε κάθε στοιχείο του πίνακα.</li>
            </ul>
            
            <h4>Μετασχηματισμός Πινάκων</h4>
            <pre><code>const numbers = [1, 2, 3, 4, 5];

// Map: μετασχηματισμός κάθε στοιχείου
const doubled = numbers.map(num => num * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

// Reduce: συσσώρευση τιμών
const sum = numbers.reduce((total, num) => total + num, 0);
console.log(sum);  // 15

// Sort: διάταξη στοιχείων
// Σημείωση: η sort() μετατρέπει τα στοιχεία σε strings από προεπιλογή
const fruits = ['πορτοκάλι', 'μήλο', 'μπανάνα'];
fruits.sort();
console.log(fruits);  // ['μήλο', 'μπανάνα', 'πορτοκάλι']

// Προσαρμοσμένη ταξινόμηση για αριθμούς
const nums = [4, 10, 2, 5, 7];
nums.sort((a, b) => a - b);
console.log(nums);  // [2, 4, 5, 7, 10]</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>map():</strong> Δημιουργεί έναν νέο πίνακα εφαρμόζοντας μια συνάρτηση σε κάθε στοιχείο του αρχικού πίνακα. Στο παράδειγμα, κάθε αριθμός διπλασιάζεται.</li>
                <li><strong>reduce():</strong> Εκτελεί μια συνάρτηση σε κάθε στοιχείο του πίνακα για να τον "συρρικνώσει" σε μία τιμή. Στο παράδειγμα, υπολογίζουμε το άθροισμα όλων των αριθμών.
                    <ul>
                        <li>Η πρώτη παράμετρος είναι μια συνάρτηση callback που δέχεται έναν συσσωρευτή (total) και το τρέχον στοιχείο (num).</li>
                        <li>Η δεύτερη παράμετρος (0) είναι η αρχική τιμή του συσσωρευτή.</li>
                    </ul>
                </li>
                <li><strong>sort():</strong> Ταξινομεί τα στοιχεία ενός πίνακα επιτόπου (in-place) και επιστρέφει τον ταξινομημένο πίνακα.
                    <ul>
                        <li>Χωρίς παραμέτρους, μετατρέπει τα στοιχεία σε strings και τα ταξινομεί αλφαβητικά.</li>
                        <li>Για αριθμητική ταξινόμηση, πρέπει να παρέχουμε μια συνάρτηση σύγκρισης.</li>
                        <li>Το <code>(a, b) => a - b</code> ταξινομεί σε αύξουσα σειρά, ενώ το <code>(a, b) => b - a</code> σε φθίνουσα.</li>
                    </ul>
                </li>
            </ul>
            
            <h4>Άλλες Χρήσιμες Μέθοδοι</h4>
            <pre><code>// Ένωση στοιχείων σε string
const fruits = ['μήλο', 'μπανάνα', 'πορτοκάλι'];
console.log(fruits.join(', '));  // 'μήλο, μπανάνα, πορτοκάλι'

// Slice: λήψη τμήματος πίνακα (μη καταστροφική)
const numbers = [1, 2, 3, 4, 5];
console.log(numbers.slice(1, 4));  // [2, 3, 4]

// Splice: αλλαγή περιεχομένου πίνακα (καταστροφική)
const letters = ['α', 'β', 'γ', 'δ'];
letters.splice(1, 2, 'χ', 'ψ');  // Αφαίρεση 2 στοιχείων από τη θέση 1, εισαγωγή 'χ' και 'ψ'
console.log(letters);  // ['α', 'χ', 'ψ', 'δ']

// Concat: συνδυασμός πινάκων
const array1 = [1, 2];
const array2 = [3, 4];
const combined = array1.concat(array2);
console.log(combined);  // [1, 2, 3, 4]</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>join():</strong> Ενώνει όλα τα στοιχεία ενός πίνακα σε ένα string, με προαιρετικό διαχωριστικό.</li>
                <li><strong>slice(start, end):</strong> Επιστρέφει ένα ρηχό αντίγραφο μέρους του πίνακα μεταξύ των δεικτών start και end (χωρίς να περιλαμβάνει το end).
                    <ul>
                        <li>Δεν τροποποιεί τον αρχικό πίνακα (μη καταστροφική).</li>
                        <li>Αν παραλειφθεί το end, λαμβάνει όλα τα στοιχεία από το start μέχρι το τέλος.</li>
                    </ul>
                </li>
                <li><strong>splice(start, deleteCount, item1, item2, ...):</strong> Αλλάζει τα περιεχόμενα ενός πίνακα αφαιρώντας ή αντικαθιστώντας υπάρχοντα στοιχεία και/ή προσθέτοντας νέα.
                    <ul>
                        <li>Τροποποιεί τον αρχικό πίνακα (καταστροφική).</li>
                        <li>Επιστρέφει έναν πίνακα με τα στοιχεία που αφαιρέθηκαν.</li>
                    </ul>
                </li>
                <li><strong>concat():</strong> Συνενώνει δύο ή περισσότερους πίνακες και επιστρέφει έναν νέο πίνακα, χωρίς να τροποποιεί τους υπάρχοντες.</li>
            </ul>
            
            <div class="callout success">
                <p><strong>Συμβουλή:</strong> Ένας εύκολος τρόπος να θυμάστε ποιες μέθοδοι τροποποιούν τον αρχικό πίνακα (καταστροφικές) και ποιες επιστρέφουν έναν νέο (μη καταστροφικές):</p>
                <table>
                    <tr>
                        <th>Καταστροφικές Μέθοδοι</th>
                        <th>Μη Καταστροφικές Μέθοδοι</th>
                    </tr>
                    <tr>
                        <td>push(), pop(), shift(), unshift()</td>
                        <td>map(), filter(), concat()</td>
                    </tr>
                    <tr>
                        <td>splice(), sort(), reverse()</td>
                        <td>slice(), join(), find(), includes()</td>
                    </tr>
                </table>
            </div>
        </section>

        <section id="error-handling">
            <h2>8. Χειρισμός Σφαλμάτων</h2>
            <p>Ο χειρισμός σφαλμάτων είναι ζωτικής σημασίας για τη δημιουργία ανθεκτικών εφαρμογών που δεν καταρρέουν όταν προκύπτουν απροσδόκητα προβλήματα.</p>
            
            <h3>try...catch...finally</h3>
            <pre><code>try {
  // Κώδικας που μπορεί να προκαλέσει σφάλμα
  const result = someUndefinedVariable + 5;
  console.log(result);  // Αυτό δεν θα εκτελεστεί αν υπάρξει σφάλμα
} catch (error) {
  // Χειρισμός του σφάλματος
  console.error('Προέκυψε σφάλμα:', error.message);
} finally {
  // Αυτό το μπλοκ εκτελείται πάντα, ανεξάρτητα από το αν υπήρξε σφάλμα
  console.log('Εργασίες καθαρισμού');
}</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li><strong>try:</strong> Περιέχει τον κώδικα που θέλετε να εκτελέσετε. Αν παρουσιαστεί σφάλμα, η εκτέλεση μεταφέρεται στο μπλοκ <code>catch</code>.</li>
                <li><strong>catch:</strong> Εκτελείται μόνο αν προκύψει σφάλμα στο μπλοκ <code>try</code>. Η παράμετρος <code>error</code> περιέχει πληροφορίες για το σφάλμα.</li>
                <li><strong>finally:</strong> Εκτελείται πάντα, ανεξάρτητα από το αν παρουσιάστηκε σφάλμα. Χρησιμοποιείται για ενέργειες καθαρισμού και απελευθέρωσης πόρων.</li>
                <li>Στο παραπάνω παράδειγμα, η μεταβλητή <code>someUndefinedVariable</code> δεν έχει οριστεί, οπότε θα προκληθεί σφάλμα και θα εκτελεστεί το μπλοκ <code>catch</code>.</li>
            </ul>
            
            <h3>Ρίψη Προσαρμοσμένων Σφαλμάτων</h3>
            <pre><code>function divide(a, b) {
  if (b === 0) {
    throw new Error('Δεν μπορεί να γίνει διαίρεση με το μηδέν');
  }
  return a / b;
}

try {
  console.log(divide(10, 2));  // 5
  console.log(divide(10, 0));  // Προκαλεί σφάλμα
} catch (error) {
  console.error(error.message);  // 'Δεν μπορεί να γίνει διαίρεση με το μηδέν'
}</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Η λέξη-κλειδί <code>throw</code> χρησιμοποιείται για να δημιουργήσετε και να ρίξετε προσαρμοσμένα σφάλματα.</li>
                <li>Το <code>new Error(message)</code> δημιουργεί ένα νέο αντικείμενο σφάλματος με το καθορισμένο μήνυμα.</li>
                <li>Όταν εκτελείται η εντολή <code>throw</code>, η λειτουργία διακόπτεται αμέσως και ο έλεγχος μεταφέρεται στο πρώτο μπλοκ <code>catch</code>.</li>
                <li>Στο παράδειγμα, η συνάρτηση <code>divide()</code> ελέγχει αν ο διαιρέτης είναι μηδέν και προκαλεί σφάλμα αν είναι.</li>
            </ul>
            
            <div class="callout">
                <p><strong>Τύποι Σφαλμάτων στη JavaScript:</strong></p>
                <ul>
                    <li><strong>Error:</strong> Η βασική κλάση σφαλμάτων.</li>
                    <li><strong>SyntaxError:</strong> Προκύπτει όταν υπάρχει σφάλμα στη σύνταξη του κώδικα.</li>
                    <li><strong>ReferenceError:</strong> Προκύπτει όταν αναφέρεστε σε μεταβλητή που δεν έχει οριστεί.</li>
                    <li><strong>TypeError:</strong> Προκύπτει όταν μια λειτουργία εκτελείται σε τιμή λάθους τύπου.</li>
                    <li><strong>RangeError:</strong> Προκύπτει όταν μια τιμή είναι εκτός επιτρεπτού εύρους.</li>
                </ul>
                <p>Μπορείτε επίσης να δημιουργήσετε προσαρμοσμένες κλάσεις σφαλμάτων επεκτείνοντας την κλάση <code>Error</code>:</p>
                <pre><code>class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}

try {
  throw new ValidationError('Μη έγκυρα δεδομένα εισόδου');
} catch (error) {
  console.log(error.name);    // 'ValidationError'
  console.log(error.message); // 'Μη έγκυρα δεδομένα εισόδου'
}</code></pre>
            </div>
        </section>

        <section id="async-javascript">
            <h2>9. Ασύγχρονη JavaScript</h2>
            <p>Οι ασύγχρονες λειτουργίες επιτρέπουν την εκτέλεση κώδικα χωρίς να μπλοκάρεται η κύρια ροή της εφαρμογής, καθιστώντας τις εφαρμογές σας πιο αποδοτικές και με καλύτερη ανταπόκριση.</p>
            
            <h3>Callbacks</h3>
            <p>Παραδοσιακός τρόπος χειρισμού ασύγχρονων λειτουργιών:</p>
            <pre><code>function fetchData(callback) {
  setTimeout(() => {
    const data = { name: 'Γιάννης', age: 30 };
    callback(data);
  }, 1000);
}

fetchData(function(data) {
  console.log(data);  // { name: 'Γιάννης', age: 30 }
});</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Ένα <strong>callback</strong> είναι μια συνάρτηση που περνιέται ως παράμετρος σε μια άλλη συνάρτηση και καλείται όταν η άλλη συνάρτηση ολοκληρώσει την εργασία της.</li>
                <li>Στο παράδειγμα, η συνάρτηση <code>fetchData</code> προσομοιώνει μια ασύγχρονη λειτουργία (π.χ., ανάκτηση δεδομένων από διακομιστή) χρησιμοποιώντας το <code>setTimeout</code>.</li>
                <li>Μετά από 1 δευτερόλεπτο, καλεί το callback με τα δεδομένα που "ανακτήθηκαν".</li>
                <li><strong>Μειονέκτημα:</strong> Τα callbacks μπορεί να οδηγήσουν σε "Callback Hell" (γνωστό και ως "Pyramid of Doom") όταν έχετε πολλές ένθετες ασύγχρονες λειτουργίες.</li>
            </ul>
            
            <h3>Promises</h3>
            <p>Σύγχρονη προσέγγιση για τον χειρισμό ασύγχρονων λειτουργιών:</p>
            <pre><code>function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = true;
      
      if (success) {
        const data = { name: 'Γιάννης', age: 30 };
        resolve(data);
      } else {
        reject(new Error('Αποτυχία ανάκτησης δεδομένων'));
      }
    }, 1000);
  });
}

fetchData()
  .then(data => {
    console.log('Λήφθηκαν δεδομένα:', data);
    return data.name;
  })
  .then(name => {
    console.log('Όνομα:', name);
  })
  .catch(error => {
    console.error('Σφάλμα:', error.message);
  })
  .finally(() => {
    console.log('Η λειτουργία ολοκληρώθηκε');
  });</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Ένα <strong>Promise</strong> είναι ένα αντικείμενο που αντιπροσωπεύει την ενδεχόμενη ολοκλήρωση (ή αποτυχία) μιας ασύγχρονης λειτουργίας.</li>
                <li>Ένα Promise μπορεί να βρίσκεται σε μία από τις ακόλουθες καταστάσεις:
                    <ul>
                        <li><strong>Pending:</strong> Αρχική κατάσταση, ούτε εκπληρωμένο ούτε απορριφθέν.</li>
                        <li><strong>Fulfilled:</strong> Η λειτουργία ολοκληρώθηκε με επιτυχία (μέσω της <code>resolve</code>).</li>
                        <li><strong>Rejected:</strong> Η λειτουργία απέτυχε (μέσω της <code>reject</code>).</li>
                    </ul>
                </li>
                <li>Η μέθοδος <code>then()</code> χρησιμοποιείται για να ορίσετε callbacks για την επιτυχία.</li>
                <li>Η μέθοδος <code>catch()</code> χρησιμοποιείται για να ορίσετε callbacks για την αποτυχία.</li>
                <li>Η μέθοδος <code>finally()</code> χρησιμοποιείται για κώδικα που πρέπει να εκτελεστεί ανεξάρτητα από την επιτυχία ή την αποτυχία.</li>
                <li>Τα Promises υποστηρίζουν την <strong>αλυσίδωση</strong>, επιτρέποντάς σας να συνδέσετε πολλαπλές ασύγχρονες λειτουργίες χωρίς ένθετα callbacks.</li>
            </ul>
            
            <h3>Async/Await</h3>
            <p>Ο πιο σύγχρονος και ευανάγνωστος τρόπος για να εργαστείτε με promises:</p>
            <pre><code>async function getData() {
  try {
    const data = await fetchData();
    console.log('Λήφθηκαν δεδομένα:', data);
    
    const name = data.name;
    console.log('Όνομα:', name);
    
    return name;
  } catch (error) {
    console.error('Σφάλμα:', error.message);
  } finally {
    console.log('Η λειτουργία ολοκληρώθηκε');
  }
}

getData().then(result => {
  console.log('Αποτέλεσμα:', result);
});</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Το <code>async/await</code> είναι "συντακτική ζάχαρη" πάνω από τα Promises, καθιστώντας τον ασύγχρονο κώδικα πιο ευανάγνωστο.</li>
                <li>Η λέξη-κλειδί <code>async</code> μπροστά από μια συνάρτηση την κάνει να επιστρέφει πάντα ένα Promise.</li>
                <li>Η λέξη-κλειδί <code>await</code> μπορεί να χρησιμοποιηθεί μόνο μέσα σε συναρτήσεις <code>async</code> και περιμένει την επίλυση ενός Promise.</li>
                <li>Το <code>await</code> αναστέλλει την εκτέλεση της συνάρτησης <code>async</code> μέχρι να επιλυθεί το Promise.</li>
                <li>Ο χειρισμός σφαλμάτων γίνεται με παραδοσιακά μπλοκ <code>try/catch</code>, καθιστώντας τον κώδικα πιο συνεπή και ευανάγνωστο.</li>
                <li>Παρόλο που η συνάρτηση <code>getData()</code> είναι <code>async</code>, εξακολουθεί να επιστρέφει ένα Promise που μπορούμε να χειριστούμε με <code>.then()</code>.</li>
            </ul>
            
            <div class="callout success">
                <p><strong>Σύγκριση των τριών προσεγγίσεων:</strong></p>
                <p>Ας συγκρίνουμε τις τρεις προσεγγίσεις για την εκτέλεση τριών διαδοχικών ασύγχρονων λειτουργιών:</p>
                
                <p><strong>1. Callbacks:</strong></p>
                <pre><code>function step1(callback) {
  setTimeout(() => callback('Αποτέλεσμα 1'), 1000);
}

function step2(input, callback) {
  setTimeout(() => callback(input + ', Αποτέλεσμα 2'), 1000);
}

function step3(input, callback) {
  setTimeout(() => callback(input + ', Αποτέλεσμα 3'), 1000);
}

// Χρήση: "Callback Hell"
step1(function(result1) {
  step2(result1, function(result2) {
    step3(result2, function(result3) {
      console.log(result3); // 'Αποτέλεσμα 1, Αποτέλεσμα 2, Αποτέλεσμα 3'
    });
  });
});</code></pre>
                
                <p><strong>2. Promises:</strong></p>
                <pre><code>function step1() {
  return new Promise(resolve => setTimeout(() => resolve('Αποτέλεσμα 1'), 1000));
}

function step2(input) {
  return new Promise(resolve => setTimeout(() => resolve(input + ', Αποτέλεσμα 2'), 1000));
}

function step3(input) {
  return new Promise(resolve => setTimeout(() => resolve(input + ', Αποτέλεσμα 3'), 1000));
}

// Χρήση: Αλυσίδωση Promises
step1()
  .then(result1 => step2(result1))
  .then(result2 => step3(result2))
  .then(result3 => {
    console.log(result3); // 'Αποτέλεσμα 1, Αποτέλεσμα 2, Αποτέλεσμα 3'
  });</code></pre>
                
                <p><strong>3. Async/Await:</strong></p>
                <pre><code>async function executeSteps() {
  const result1 = await step1();
  const result2 = await step2(result1);
  const result3 = await step3(result2);
  console.log(result3); // 'Αποτέλεσμα 1, Αποτέλεσμα 2, Αποτέλεσμα 3'
}

executeSteps();</code></pre>
                
                <p>Το <code>async/await</code> παρέχει την πιο καθαρή και διαισθητική σύνταξη, ιδιαίτερα για πολύπλοκες αλυσίδες ασύγχρονων λειτουργιών.</p>
            </div>
        </section>

        <section id="es6-features">
            <h2>10. Χαρακτηριστικά ES6+</h2>
            <p>Οι νεότερες εκδόσεις της JavaScript (ES6 και μετά) εισήγαγαν πολλά χρήσιμα χαρακτηριστικά που κάνουν τον κώδικα πιο καθαρό, συνοπτικό και ισχυρό.</p>
            
            <h3>Template Literals</h3>
            <pre><code>const name = 'Γιάννης';
const age = 30;

// Παλιός τρόπος
const message1 = 'Ονομάζομαι ' + name + ' και είμαι ' + age + ' ετών.';

// Χρήση template literals
const message2 = `Ονομάζομαι ${name} και είμαι ${age} ετών.`;

// Πολυγραμμικά strings
const multiLine = `Αυτή είναι η γραμμή 1.
Αυτή είναι η γραμμή 2.
Αυτή είναι η γραμμή 3.`;</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Τα <strong>template literals</strong> περικλείονται σε ανάποδα εισαγωγικά (<code>``</code>) αντί για μονά ή διπλά εισαγωγικά.</li>
                <li>Επιτρέπουν την <strong>ενσωμάτωση εκφράσεων</strong> μέσα σε strings χρησιμοποιώντας τη σύνταξη <code>${expression}</code>.</li>
                <li>Υποστηρίζουν <strong>πολυγραμμικά strings</strong> χωρίς να χρειάζεστε ειδικούς χαρακτήρες όπως <code>\n</code>.</li>
                <li>Μπορείτε επίσης να εκτελέσετε λειτουργίες μέσα στα <code>${}</code>, π.χ., <code>${name.toUpperCase()}</code> ή <code>${a + b}</code>.</li>
            </ul>
            
            <h3>Αποδόμηση (Destructuring)</h3>
            <pre><code>// Αποδόμηση αντικειμένων
const person = {
  name: 'Γιάννης',
  age: 30,
  location: 'Αθήνα'
};

const { name, age } = person;
console.log(name, age);  // 'Γιάννης' 30

// Αποδόμηση πινάκων
const colors = ['κόκκινο', 'πράσινο', 'μπλε'];
const [firstColor, secondColor] = colors;
console.log(firstColor, secondColor);  // 'κόκκινο' 'πράσινο'

// Προεπιλεγμένες τιμές
const { city = 'Άγνωστη' } = person;
console.log(city);  // 'Άγνωστη'</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Η <strong>αποδόμηση</strong> επιτρέπει την εξαγωγή πολλαπλών τιμών από αντικείμενα ή πίνακες σε ξεχωριστές μεταβλητές με μια συνοπτική σύνταξη.</li>
                <li><strong>Αποδόμηση αντικειμένων:</strong> Οι μεταβλητές πρέπει να έχουν το ίδιο όνομα με τις ιδιότητες του αντικειμένου που θέλετε να εξάγετε.</li>
                <li><strong>Αποδόμηση πινάκων:</strong> Οι μεταβλητές εκχωρούνται με τη σειρά των στοιχείων στον πίνακα.</li>
                <li><strong>Προεπιλεγμένες τιμές:</strong> Μπορείτε να καθορίσετε προεπιλεγμένες τιμές που θα χρησιμοποιηθούν αν η ιδιότητα δεν υπάρχει ή έχει τιμή <code>undefined</code>.</li>
                <li>Μπορείτε επίσης να αλλάξετε τα ονόματα των μεταβλητών κατά την αποδόμηση: <code>const { name: fullName } = person;</code></li>
            </ul>
            
            <h3>Τελεστές Spread και Rest</h3>
            <pre><code>// Τελεστής spread με πίνακες
const numbers1 = [1, 2, 3];
const numbers2 = [4, 5, 6];
const combined = [...numbers1, ...numbers2];
console.log(combined);  // [1, 2, 3, 4, 5, 6]

// Τελεστής spread με αντικείμενα
const person = {
  name: 'Γιάννης',
  age: 30
};

const employee = {
  ...person,
  position: 'Προγραμματιστής',
  salary: 50000
};
console.log(employee);  // { name: 'Γιάννης', age: 30, position: 'Προγραμματιστής', salary: 50000 }

// Παράμετρος rest σε συναρτήσεις
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5));  // 15</code></pre>
            
            <p><strong>Επεξήγηση:</strong></p>
            <ul>
                <li>Τόσο ο τελεστής <strong>spread</strong> όσο και ο <strong>rest</strong> χρησιμοποιούν την ίδια σύνταξη (<code>...</code>), αλλά σε διαφορετικά πλαίσια:</li>
                <li><strong>Τελεστής Spread:</strong>
                    <ul>
                        <li>"Απλώνει" έναν πίνακα ή ένα αντικείμενο στα επιμέρους στοιχεία του.</li>
                        <li>Χρησιμοποιείται για τη συνένωση πινάκων ή αντικειμένων, την αντιγραφή και την επέκταση.</li>
                        <li>Με αντικείμενα, αν οι ιδιότητες έχουν το ίδιο όνομα, η τελευταία τιμή επικρατεί.</li>
                    </ul>
                </li>
                <li><strong>Παράμετρος Rest:</strong>
                    <ul>
                        <li>Συλλέγει πολλαπλά επιχειρήματα σε έναν πίνακα.</li>
                        <li>Χρησιμοποιείται σε παραμέτρους συναρτήσεων για τη διαχείριση απεριόριστου αριθμού επιχειρημάτων.</li>
                        <li>Πρέπει να είναι η τελευταία παράμετρος στον ορισμό της συνάρτησης.</li>
                    </ul>
                </li>
            </ul>
            
            <div class="callout success">
                <p><strong>Πρακτικές εφαρμογές σύγχρονων χαρακτηριστικών της JavaScript:</strong></p>
                
                <h4>1. Αντιγραφή πινάκων και αντικειμένων</h4>
                <pre><code>// Αντιγραφή πίνακα
const original = [1, 2, 3];
const copy = [...original];

// Αντιγραφή αντικειμένου
const originalObj = { a: 1, b: 2 };
const copyObj = { ...originalObj };</code></pre>
                
                <h4>2. Συνδυασμός αποδόμησης και τελεστή spread</h4>
                <pre><code>const person = {
  name: 'Γιάννης',
  age: 30,
  city: 'Αθήνα',
  country: 'Ελλάδα'
};

// Εξαγωγή κάποιων ιδιοτήτων και συλλογή των υπολοίπων
const { name, age, ...address } = person;
console.log(name);     // 'Γιάννης'
console.log(age);      // 30
console.log(address);  // { city: 'Αθήνα', country: 'Ελλάδα' }</code></pre>
                
                <h4>3. Δημιουργία αντιγράφων με τροποποιήσεις (χρήσιμο για λειτουργικό προγραμματισμό)</h4>
                <pre><code>const person = {
  name: 'Γιάννης',
  age: 30
};

// Δημιουργία νέου αντικειμένου με μία τροποποιημένη ιδιότητα
const updatedPerson = {
  ...person,
  age: 31  // Ενημέρωση μόνο της ηλικίας
};</code></pre>
            </div>
        </section>
    </div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-jsx.min.js"></script>

<button id="back-to-top" title="Back to top">↑</button>
<script src="course-interactions.js"></script>

<script>
    const backToTopButton = document.getElementById('back-to-top');
  
  window.addEventListener('scroll', () => {
    if (window.pageYOffset > 300) {
      backToTopButton.style.display = 'block';
    } else {
      backToTopButton.style.display = 'none';
    }
  });
  
  backToTopButton.addEventListener('click', () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  });
</script>
</body>
</html>